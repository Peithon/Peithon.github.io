<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Peithon&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://peithon.github.io/"/>
  <updated>2018-12-10T23:02:49.292Z</updated>
  <id>https://peithon.github.io/</id>
  
  <author>
    <name>Peithon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用frp实现内网穿透</title>
    <link href="https://peithon.github.io/2018/12/11/frp-test/"/>
    <id>https://peithon.github.io/2018/12/11/frp-test/</id>
    <published>2018-12-10T22:42:26.000Z</published>
    <updated>2018-12-10T23:02:49.292Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用frp工具实现内网穿透"><a href="#使用frp工具实现内网穿透" class="headerlink" title="使用frp工具实现内网穿透"></a>使用frp工具实现内网穿透</h1><p>最近在学校内部搭建了一个Web服务环境，想通过公网来访问，所以研究了一下内网穿透，网上有很多方法来实现内网穿透，大多数都是收费的，像<code>ngrok</code>和<code>frp</code>这样的可以自己搭建，所以本着学习的想法，打算自己搭建一个，使用frp工具来实现。<a id="more"></a></p><h2 id="0x01-原理"><a href="#0x01-原理" class="headerlink" title="0x01 原理"></a>0x01 原理</h2><p>一般来说，学习的话就得把原理弄清楚，不然做出来能用以后碰到类似的也就记得不太深，所以这里就要唠叨一下内网穿透的原理了，当然也是从网上<a href="https://zhuanlan.zhihu.com/p/30351943" target="_blank" rel="noopener">大神</a>的文章学习来的。</p><p>公网主机先监听一个端口(<code>8888端口</code>为例)，监听这个端口是用于向外部提供一个HTTP服务。同时其他任意一个端口（这里我们假设为7777），监听这个端口是用于让内网服务器主动连接进来打通一个隧道。接着内网再主动向公网主机的7777发起一个请求，这样内网就成功与公网主机建立了一个连接通道。然后当有任何客户端主动连接公网的<code>8888端口</code>时，公网接收到连接请求之后马上把这连接请求通过先前建立好的隧道转发到内网主机，内网主机接收到来自隧道的数据包后再主动连接内网主机自身的80端口(也可以为自己定义web服务端口)，连接成功之后将数据包原封不动地转发数据包给80端口，待HTTP服务器程序处理完这个数据包，生成了响应报文之后再原路转发回去，最终到达公网的<code>8888端口</code>，然后返回给最开始请求公网服务器<code>8888端口</code>的客户端。</p><h2 id="0x02-前期准备"><a href="#0x02-前期准备" class="headerlink" title="0x02 前期准备"></a>0x02 前期准备</h2><ul><li>公网服务器一个(我使用的是阿里云服务器CentOS7)</li><li>内网服务器一个(我的是Linux系统)</li><li><a href="https://github.com/fatedier/frp/blob/master/README_zh.md" target="_blank" rel="noopener">阅读frp官方文档</a></li><li><a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">frp各版本下载链接</a></li><li>在内网服务器上放一个测试页面（非必须）</li><li>父域名和公网IP绑定</li></ul><h2 id="0x03-服务器端配置-公网ip的服务器上"><a href="#0x03-服务器端配置-公网ip的服务器上" class="headerlink" title="0x03 服务器端配置(公网ip的服务器上)"></a>0x03 服务器端配置(公网ip的服务器上)</h2><h3 id="3-1-GitHub上下载代码"><a href="#3-1-GitHub上下载代码" class="headerlink" title="3.1 GitHub上下载代码"></a>3.1 GitHub上下载代码</h3><pre><code>mkdir /usr/frpcd /usr/frpwget https://github.com/fatedier/frp/releases/download/v0.22.0/frp_0.22.0_linux_amd64.tar.gztar -zxvf frp_0.22.0_linux_amd64.tar.gz </code></pre><h3 id="3-2-修改配置文件"><a href="#3-2-修改配置文件" class="headerlink" title="3.2 修改配置文件"></a>3.2 修改配置文件</h3><p>服务端要使用的文件是<code>frps.ini</code>和<code>frps</code>这两个文件，进入刚刚解压之后的目录</p><pre><code>cat frps.ini[common]bind_port = 7000</code></pre><p>关于<code>frps.ini</code>的完整配置文件参考同级目录下的<code>frps_full.ini</code>或者<a href="https://github.com/fatedier/frp/blob/master/conf/frps_full.ini" target="_blank" rel="noopener">官方文档frps_full.ini</a></p><p>修改配置文件内容：</p><pre><code>vi frps.ini[common]bind_port = 7000# 填写 frp 服务端密码token = 12345678    #访问客户端web服务自定义的端口号vhost_http_port = 8888vhost_https_port = 443#dashboard_addr和dashboard_port查看FRPS的仪表盘dashboard_addr = 0.0.0.0dashboard_port = 7500#为基本身份验证面板用户和passwd保护，如果没有设置，包括默认值为admindashboard_user = admindashboard_pwd = admin</code></pre><h2 id="3-3-启动frps"><a href="#3-3-启动frps" class="headerlink" title="3.3     启动frps"></a>3.3     启动frps</h2><h3 id="3-3-1-前端启动"><a href="#3-3-1-前端启动" class="headerlink" title="3.3.1 前端启动"></a>3.3.1 前端启动</h3><pre><code># 使用 -c 参数指定配置文件,使用Ctrl+C终止程序./frps -c frps.ini</code></pre><p>说明启动成功了，但是直接使用这里的命令行来运行是不行的，因为在关掉<code>ssh</code>窗口后程序frps就会停止运行，因此要使用<code>nohup [command] &amp;</code>这种操作来使其在后台运行.</p><h3 id="3-3-2-后台启动"><a href="#3-3-2-后台启动" class="headerlink" title="3.3.2 后台启动"></a>3.3.2 后台启动</h3><pre><code>nohup /usr/frp/frp_0.22.0_linux_amd64/frps -c /usr/frp/frp_0.22.0_linux_amd64/frps.ini &amp;</code></pre><h3 id="3-3-3-停止"><a href="#3-3-3-停止" class="headerlink" title="3.3.3 停止"></a>3.3.3 停止</h3><pre><code>pkill frps</code></pre><h2 id="0x04-客服端配置-内网IP的服务器上"><a href="#0x04-客服端配置-内网IP的服务器上" class="headerlink" title="0x04 客服端配置(内网IP的服务器上)"></a>0x04 客服端配置(内网IP的服务器上)</h2><p>下载对应操作系统的压缩包，然后解压，进入解压后的目录，这里直接写怎么配置，其他的就不细说了。</p><p>主要用到的文件是<code>frpc.ini</code>和<code>frpc</code>,关于<code>frpc.ini</code>的完整配置文件参考同级目录下的<code>frpc_full.ini</code>或者<a href="https://github.com/fatedier/frp/blob/master/conf/frpc_full.ini" target="_blank" rel="noopener">官方文档frps_full.ini</a></p><p>首先查看配置文件默认的配置内容，<code>cat frpc.ini</code></p><pre><code>[common]server_addr = 127.0.0.1   server_port = 7000              [ssh]type = tcp     local_ip = 127.0.0.1local_port = 22    remote_port = 6000   </code></pre><p>在默认的客户端配置文件当中，配置了一个TCP映射，不过我们需要搭建Web服务，因此还需要添加一个HTTP映射，并修改对应的服务端IP地址。</p><p>修改配置文件内容：</p><pre><code>[common]#公网服务器ipserver_addr = 39.106.201.219 #与服务端bind_port一致   server_port = 7000              token = 12345678[ssh]#连接协议type = tcp #内网服务器Ip       local_ip = 10.203.87.22 #ssh默认端口号local_port = 22#自定义的访问内部ssh端口号      remote_port = 6000   [web]#访问协议type = http#内网服务器Ip         local_ip = 10.203.87.22 #内网web服务的端口号local_port = 80 #所绑定的公网服务器域名，一级、二级域名都可以   custom_domains = zyddn.club </code></pre><p>启动客户端<code>./frpc -c frpc.ini</code></p><p><strong>后台启动命令和对应的停止命令与服务端的frp一样</strong></p><h2 id="0x05-测试"><a href="#0x05-测试" class="headerlink" title="0x05 测试"></a>0x05 测试</h2><h3 id="5-1-测试失败，出现错误"><a href="#5-1-测试失败，出现错误" class="headerlink" title="5.1 测试失败，出现错误"></a>5.1 测试失败，出现错误</h3><p>浏览器访问<code>zyddn.club:8888</code>,结果是<code>The page you visit not found</code></p><p>服务端提示： <code>[W] [newhttp.go:209] http: proxy error: no such domain</code></p><p>客户端提示：<code>connect: connection refused</code></p><h3 id="5-2-解决方法"><a href="#5-2-解决方法" class="headerlink" title="5.2 解决方法"></a>5.2 解决方法</h3><p>查看apache有没有启动,这回比较智障，居然忽略了查看服务状态。</p><p>再次访问:</p><pre><code>zyddn.club:8888</code></pre><p>测试结果，回显正常</p><h3 id="5-3-另一种配置方法，其实大致差不多"><a href="#5-3-另一种配置方法，其实大致差不多" class="headerlink" title="5.3 另一种配置方法，其实大致差不多"></a>5.3 另一种配置方法，其实大致差不多</h3><p>服务端：</p><pre><code>[common]bind_port = 5000# 填写 frp 服务端密码token = 12345678#访问客户端web服务自定义的端口号vhost_http_port = 8888vhost_https_port = 3344#dashboard_addr和dashboard_port查看FRPS的仪表盘dashboard_addr = 0.0.0.0dashboard_port = 4000#为基本身份验证面板用户和passwd保护，如果没有设置，包括默认值为admindashboard_user = admindashboard_pwd = admin# 此设置需要配合客户端设置，仅在穿透到内网中的 http 或 https 时有用（可选）# 假设此项设置为 example.com，客户端配置 http 时将 subdomain 设置为 test，# 则你将 test.example.com 解析到服务端后，可以使用此域名来访问客户端对应的 httpsubdomain_host = zyddn.club</code></pre><p>客户端:</p><pre><code>[common]server_addr = 39.106.201.219server_port = 5000token = 12345678[ssh]type = tcplocal_ip = 10.203.87.22local_port = 22remote_port = 6000[web]type = httplocal_ip = 10.203.87.22local_port = 80subdomain = test</code></pre><p>访问:</p><pre><code>test.zyddn.club:8888</code></pre><p>测试结果，回显正常</p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h2><p>关于apache没开启那件事我觉得需要解释一下，因为我之前测试内网穿透的时候是开了的，完全没有想到是apache的问题啊，天地良心，话说，这此的内网穿透实践的确学到新的东西了，感觉人生又充满了活力,这是一条不正经的总结。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用frp工具实现内网穿透&quot;&gt;&lt;a href=&quot;#使用frp工具实现内网穿透&quot; class=&quot;headerlink&quot; title=&quot;使用frp工具实现内网穿透&quot;&gt;&lt;/a&gt;使用frp工具实现内网穿透&lt;/h1&gt;&lt;p&gt;最近在学校内部搭建了一个Web服务环境，想通过公网来访问，所以研究了一下内网穿透，网上有很多方法来实现内网穿透，大多数都是收费的，像&lt;code&gt;ngrok&lt;/code&gt;和&lt;code&gt;frp&lt;/code&gt;这样的可以自己搭建，所以本着学习的想法，打算自己搭建一个，使用frp工具来实现。
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
    
      <category term="内网穿透" scheme="https://peithon.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
      <category term="frp" scheme="https://peithon.github.io/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>apache虚拟主机配置-基于端口</title>
    <link href="https://peithon.github.io/2018/08/11/httpd-vhosts/"/>
    <id>https://peithon.github.io/2018/08/11/httpd-vhosts/</id>
    <published>2018-08-11T14:03:43.000Z</published>
    <updated>2018-10-13T00:01:43.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>配置Apache虚拟主机，主要是监听端口，编写虚拟主机配置文件，开放端口，还有就是将web站点的目录建好。<br><a id="more"></a></p><h2 id="0x01-监听端口8001"><a href="#0x01-监听端口8001" class="headerlink" title="0x01 监听端口8001"></a>0x01 监听端口8001</h2><p>修改Apache的配置文件，监听8001端口，这是用于对外进行站点访问的端口。</p><pre><code>vi /etc/httpd/conf/httpd.conf</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-8-11/9452670.jpg" alt=""></p><h2 id="0x02-编写虚拟主机配置文件"><a href="#0x02-编写虚拟主机配置文件" class="headerlink" title="0x02 编写虚拟主机配置文件"></a>0x02 编写虚拟主机配置文件</h2><pre><code>vi /etc/httpd/conf.d/vhosts.conf</code></pre><p>添加以下内容：</p><pre><code>&lt;VirtualHost *:端口号&gt;#ServerName www.***.com #域名DocumentRoot /var/www/html/web #网站目录,自己定                 ErrorLog &quot;/var/log/httpd/web/error_log&quot;            CustomLog &quot;/var/log/httpd/web/access_log&quot; combined  &lt;Directory &quot;/var/www/html/web&quot;&gt;Options -Indexes +Includes +FollowSymLinks +MultiViewsAllowOverride AllRequire all granted            &lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><p>这是我在服务器上的配置:</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-8-11/52946496.jpg" alt=""></p><h2 id="0x03-添加目录"><a href="#0x03-添加目录" class="headerlink" title="0x03 添加目录"></a>0x03 添加目录</h2><pre><code>mkdir -pv /var/log/httpd/testmkdir -pv /var/www/test</code></pre><h2 id="0x04-修改-etc-httpd-conf-d-welcome-conf文件"><a href="#0x04-修改-etc-httpd-conf-d-welcome-conf文件" class="headerlink" title="0x04 修改/etc/httpd/conf.d/welcome.conf文件"></a>0x04 修改<code>/etc/httpd/conf.d/welcome.conf</code>文件</h2><p>这个文件是apache的测试文件，所以我们这里将该文件内容全部注释掉</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-8-11/95888125.jpg" alt=""></p><p><strong>为什么<code>httpd.conf</code>配置文件可以加载<code>welcome.conf</code>和<code>vhosts.conf</code>文件呢？</strong></p><p>原因很简单,因为<code>httpd.conf</code>的最后有这样一行代码</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-8-11/80399711.jpg" alt=""></p><p>这一行代码会使Apache配置文件将<code>/etc/httpd/conf.d</code>目录下的<code>.conf</code>文件给包含，所以可以读取到我们新建的<code>vhosts.conf</code>文件。</p><h2 id="0x04-重启apache服务-执行其中一个即可"><a href="#0x04-重启apache服务-执行其中一个即可" class="headerlink" title="0x04 重启apache服务(执行其中一个即可)"></a>0x04 重启apache服务(执行其中一个即可)</h2><pre><code>systemctl restart httpd/etc/init.d/httpd restart</code></pre><h2 id="0x05-开放端口，注意把SELinux关闭"><a href="#0x05-开放端口，注意把SELinux关闭" class="headerlink" title="0x05 开放端口，注意把SELinux关闭"></a>0x05 开放端口，注意把SELinux关闭</h2><pre><code>#永久生效加上 --permanentfirewall-cmd --zone=public --add-port=8001/tcp --permanent</code></pre><h2 id="0x06-测试"><a href="#0x06-测试" class="headerlink" title="0x06 测试"></a>0x06 测试</h2><p>编写一个<code>index.html</code>进行测试</p><pre><code>echo &quot;hello,this is test page&quot; &gt; /var/www/test/index.html</code></pre><p>使用<code>curl</code>访问页面</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-8-11/35385086.jpg" alt=""></p><p>同时我们可以在<code>test</code>的访问成功的日志<code>access_log</code>中看到相关信息</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-8-11/34145704.jpg" alt=""></p><p><strong>如果想在不同的端口配置不同目录下的站点，可以在<code>httpd.conf</code>中添加相应端口，在<code>vhosts.conf</code>文件中添加相应站点信息，然后再防火墙中将端口开放，这样就可以实现同IP多端口的多个Web站点</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;配置Apache虚拟主机，主要是监听端口，编写虚拟主机配置文件，开放端口，还有就是将web站点的目录建好。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
    
      <category term="多端口" scheme="https://peithon.github.io/tags/%E5%A4%9A%E7%AB%AF%E5%8F%A3/"/>
    
      <category term="vhosts" scheme="https://peithon.github.io/tags/vhosts/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建Web测试环境一般步骤及相关命令总结</title>
    <link href="https://peithon.github.io/2018/07/22/docker-bridge-test/"/>
    <id>https://peithon.github.io/2018/07/22/docker-bridge-test/</id>
    <published>2018-07-21T18:38:13.000Z</published>
    <updated>2018-10-13T00:01:03.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近学习Docker中web环境的搭建，所以记录一下搭建过程中需要用到的命令以及相关步骤，本次搭建的数据库是从别的主机导出来的，所以还会涉及到一点SQL文件的导入和导出相关操作。<br><a id="more"></a></p><h2 id="0x01-pull-lamp镜像"><a href="#0x01-pull-lamp镜像" class="headerlink" title="0x01 pull lamp镜像"></a>0x01 pull lamp镜像</h2><p>查找Docker Hub上的lamp镜像</p><pre><code>[root@Peithon ~]# docker search lampNAME                                   DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDlinode/lamp                            LAMP on Ubuntu 14.04.1 LTS Container            144                                     tutum/lamp                             Out-of-the-box LAMP image (PHP+MySQL)           97                                      greyltc/lamp                           a super secure, up-to-date and lightweight L…   85                                      [OK]fauria/lamp                            Modern, developer friendly LAMP stack. Inclu…   41                                      [OK]janes/alpine-lamp                      lamp base on alpine linux                       35                                      [OK]nickistre/ubuntu-lamp                  LAMP server on Ubuntu                           26                                      [OK]mattrayner/lamp                        A simple LAMP docker image running the prere…   22                                      [OK]nickistre/centos-lamp                  LAMP on centos setup                            21                                      [OK]nickistre/ubuntu-lamp-wordpress        LAMP on Ubuntu with wp-cli installed            9                                       [OK]lioshi/lamp                            Docker image for LAMP + MySql under debian      9                                       [OK]x4j5/silverstripe-lamp                 lamp stack for silverstripe development (Deb…   5                                       [OK]nickistre/ubuntu-lamp-xdebug           LAMP on Ubuntu with xdebug installed            4                                       [OK]sminnee/silverstripe-lamp              Docker image for SilverStripe LAMP stack tha…   4                                       nickistre/centos-lamp-wordpress        LAMP on CentOS setups with wp-cli installed     3                                       [OK]dell/lamp-base                         Base LAMP Image for dependant images            3                                       nickistre/centos-lamp-xdebug           LAMP on centos with xDebug                      3                                       [OK]shelleyma/lampp2                       lampp from github                               2                                       [OK]gizra/drupal-lamp                      A base LAMP docker file for drupal projects.    2                                       [OK]theodotos/ubuntu-lamp                  A LAMP (Linux/Apache/MariaDB/PHP) image base…   2                                       lead4good/lamp-php                     LAMP Stack PHP                                  1                                       [OK]ready2order/lamp                       LAMP                                            1                                       thinkiq/lamp                           ThinkIQ Lamp image                              0                                       [OK]davefx/trusty-lamp-selenium-headless   Ubuntu 14.04 system with configured LAMP ser…   0                                       [OK]greyltc/lamp-aur                       LAMP stack (in Arch with php7) with AUR acce…   0                                       [OK]lead4good/lamp-mysql                   LAMP-Stack MySQL                                0                                       [OK]</code></pre><p>拉取镜像到本地</p><pre><code>[root@Peithon ~]# docker pull tutum/lamp</code></pre><h2 id="0x02-网络模式的选择"><a href="#0x02-网络模式的选择" class="headerlink" title="0x02 网络模式的选择"></a>0x02 网络模式的选择</h2><p>使用docker run创建Docker容器时，需要根据自己的需要选择容器的网络模式，在Docker中有四种网络模式可以供我们选择,通常使用birdge模式比较多见。</p><h3 id="1-bridge模式：使用–net-bridge指定，默认设置"><a href="#1-bridge模式：使用–net-bridge指定，默认设置" class="headerlink" title="1). bridge模式：使用–net=bridge指定，默认设置"></a>1). bridge模式：使用–net=bridge指定，默认设置</h3><p>当我们的Docker server启动时，会在主机创建一个docker0的虚拟网桥，当我们选择使用bridge模式，会为每一个容器分配Network Namespace、设置IP等，每个bridge模式的容器之间可以相互通信，主机和容器之间可以相互通信，但是外部无法访问到这些容器，而docker0就类似于交换机一样的功能。</p><pre><code># [root@Peithon ~]# docker run -d --name=webtest --net=bridge 3d49e175ec00</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/86203460.jpg" alt=""></p><p>可以看到会从<code>172.17.0.0/16</code>这个网段随机分配一个没有被使用的ip，因为网络模式默认是使用bridge模式的，所以可以不用使用命令来指定。</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/10613190.jpg" alt=""></p><p>使用<code>docker network inspect bridge</code>可以查看该网络模式下有哪些容器</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/13840395.jpg" alt=""></p><h3 id="2-host模式：使用–net-host指定"><a href="#2-host模式：使用–net-host指定" class="headerlink" title="2). host模式：使用–net=host指定"></a>2). host模式：使用–net=host指定</h3><p>启动容器时使用host模式，容器将不会拥有自己独立的Network Namespace和IP,而是和主机共享同一个Network Namespace，容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p><pre><code>[root@Peithon ~]# docker run -d --name=webtest3 --net=host 3d49e175ec00</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/933791.jpg" alt=""></p><p>下面是主机的</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/70381321.jpg" alt=""></p><p>查看网络模式为host的信息</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/45046857.jpg" alt=""></p><p>通过这种方式创建的容器，容器发生端口冲突</p><h3 id="3-none模式：使用–net-none指定-也可以使用–network-none"><a href="#3-none模式：使用–net-none指定-也可以使用–network-none" class="headerlink" title="3). none模式：使用–net=none指定(也可以使用–network none)"></a>3). none模式：使用–net=none指定(也可以使用–network none)</h3><p>该模式有自己独立的Network Namespace，但不为Docker容器进行任何网络配置，需要自己手动添加。</p><pre><code>[root@Peithon ~]# docker run -d --name webtest4 --network none 3d49e175ec00</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/37931981.jpg" alt=""></p><p>这种模式下的容器外部无法访问，可以放一些重要的文件或者工具，这样只有本地可以访问，安全性会比较高。</p><h3 id="4-container模式：使用–net-container-NAMEorID指定"><a href="#4-container模式：使用–net-container-NAMEorID指定" class="headerlink" title="4). container模式：使用–net=container:NAMEorID指定"></a>4). container模式：使用–net=container:NAMEorID指定</h3><p>指定新创建的容器和已经存在的一个容器共用一个Network Namespace，而不是和宿主机共享，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</p><pre><code>[root@Peithon ~]# docker run -d --name webtest5 --network container:webtest 3d49e175ec00</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/87420309.jpg" alt=""></p><p>可以看出<code>webtest5</code>和<code>webtest</code>是共享网络的。</p><p><strong>本次搭建将使用bridge模式,并将上面测试所建容器删除</strong></p><h2 id="0x03-创建容器，并将80端口转发到宿主机的8001端口"><a href="#0x03-创建容器，并将80端口转发到宿主机的8001端口" class="headerlink" title="0x03 创建容器，并将80端口转发到宿主机的8001端口"></a>0x03 创建容器，并将80端口转发到宿主机的8001端口</h2><pre><code>[root@Peithon ~]# docker run -d --name test1 -p 8001:80 tutum/lamp</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/6726241.jpg" alt=""></p><p>通过将容器的端口转发到宿主机，在宿主机上可以访问本机的端口来访问Docker容器中的服务</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/40033266.jpg" alt=""></p><p>在防火墙开放8001端口，使外部网络也能对其进行访问</p><pre><code>[root@Peithon ~]# firewall-cmd --zone=public --add-port=8001/tcp --permanent[root@Peithon ~]# firewall-cmd --reload #重启firewall</code></pre><h2 id="0x04-主机和容器之间文件的拷贝"><a href="#0x04-主机和容器之间文件的拷贝" class="headerlink" title="0x04 主机和容器之间文件的拷贝"></a>0x04 主机和容器之间文件的拷贝</h2><h3 id="1-将本地的-opt-src-Web1下的html文件拷贝到test1容器中的-var-www目录下"><a href="#1-将本地的-opt-src-Web1下的html文件拷贝到test1容器中的-var-www目录下" class="headerlink" title="1).将本地的/opt/src/Web1下的html文件拷贝到test1容器中的/var/www目录下"></a>1).将本地的<code>/opt/src/Web1</code>下的<code>html</code>文件拷贝到<code>test1</code>容器中的<code>/var/www</code>目录下</h3><p><strong><em>docker cp 宿主机中要拷贝的文件名及其路径 容器名：要拷贝到容器里面对应的路径</em></strong></p><p>在宿主机执行命令</p><pre><code>[root@Peithon ~]# docker cp /opt/src/Web1/html test1:/var/www</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/3109291.jpg" alt=""></p><h3 id="2-将test1容器中的-var-www目录下的html文件拷贝到本地的-opt-src-Web1下"><a href="#2-将test1容器中的-var-www目录下的html文件拷贝到本地的-opt-src-Web1下" class="headerlink" title="2).将test1容器中的/var/www目录下的html文件拷贝到本地的/opt/src/Web1下"></a>2).将<code>test1</code>容器中的<code>/var/www</code>目录下的<code>html</code>文件拷贝到本地的<code>/opt/src/Web1</code>下</h3><p>在宿主机执行命令</p><pre><code>[root@Peithon ~]# docker cp test1:/var/www/html /opt/src/Web1</code></pre><p><strong>拷贝命令不管容器有没有启动都生效</strong></p><p>通过<code>docker cp</code>将宿主机上的站点文件拷贝到Docker容器中</p><h2 id="0x05-从宿主机的数据库中导出SQL文件，导入到Docker中的数据库中"><a href="#0x05-从宿主机的数据库中导出SQL文件，导入到Docker中的数据库中" class="headerlink" title="0x05 从宿主机的数据库中导出SQL文件，导入到Docker中的数据库中"></a>0x05 从宿主机的数据库中导出SQL文件，导入到Docker中的数据库中</h2><p><strong><em>mysqldump -h localhost -u root -p 数据库名 &gt;/opt/src/Web1/dbsqlfile.sql</em></strong></p><pre><code>[root@Peithon ~]# mysqldump -h localhost -u root -p ctf1003 &gt;/opt/src/Web1/dbctf1003.sql</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/53428903.jpg" alt=""></p><p>输入密码，到此将mysql数据库中的ctf1003数据库导出到dbctf1003.sql文件中了</p><p>Docker中的数据库默认没有密码的，所以还需要我们设置一下密码</p><pre><code>#登录数据库之后&gt;set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;123456&apos;);&gt;create database ctf1003;</code></pre><p>将SQL文件导入数据到Docker容器中的数据库中</p><pre><code>[root@Peithon ~]# mysql -h localhost -u root -p ctf1003 &lt; /opt/src/Web1/dbctf1003.sql</code></pre><p>输入密码，然后就OK了</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/23561606.jpg" alt=""></p><h2 id="0x06-提交容器打包成新的镜像"><a href="#0x06-提交容器打包成新的镜像" class="headerlink" title="0x06 提交容器打包成新的镜像"></a>0x06 提交容器打包成新的镜像</h2><pre><code>[root@Peithon ~]# docker commit -a &quot;Peithon&quot; -m &quot;Web 测试&quot; e61c66465773 ubuntu:web500</code></pre><p>e61c66465773 ：CONTAINER ID<br>ubuntu:web500 -&gt;新镜像的REPOSITORY:TAG</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/93957858.jpg" alt=""></p><p>查看刚打包的镜像</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/34640633.jpg" alt=""></p><h2 id="0x07-上传到Docker-Hub上"><a href="#0x07-上传到Docker-Hub上" class="headerlink" title="0x07 上传到Docker Hub上"></a>0x07 上传到Docker Hub上</h2><h3 id="1-标记镜像"><a href="#1-标记镜像" class="headerlink" title="1). 标记镜像"></a>1). 标记镜像</h3><p><strong><em>docker tag image username/repository:tag</em></strong></p><pre><code>[root@Peithon ~]# docker tag ubuntu:web500 peithon/ubuntu:web500</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/17405184.jpg" alt=""></p><h3 id="2-Docker-Hub账号登录"><a href="#2-Docker-Hub账号登录" class="headerlink" title="2).Docker Hub账号登录"></a>2).Docker Hub账号登录</h3><pre><code>[root@Peithon ~]# docker login</code></pre><p>然后输入用户密码，登录成功之后将镜像标记然后上传。</p><h3 id="3-将标记镜像上传到存储库"><a href="#3-将标记镜像上传到存储库" class="headerlink" title="3).将标记镜像上传到存储库"></a>3).将标记镜像上传到存储库</h3><p><strong><em>docker push username/repository:tag</em></strong></p><pre><code>[root@Peithon ~]# docker push peithon/ubuntu:web500</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/30524912.jpg" alt=""></p><p>登录到Docker Hub上查看是否上传成功</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-7-21/3341134.jpg" alt=""></p><p>至此就基本完成了环境的搭建</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;最近学习Docker中web环境的搭建，所以记录一下搭建过程中需要用到的命令以及相关步骤，本次搭建的数据库是从别的主机导出来的，所以还会涉及到一点SQL文件的导入和导出相关操作。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
      <category term="Docker" scheme="https://peithon.github.io/categories/Linux/Docker/"/>
    
    
      <category term="sql文件导出和导入" scheme="https://peithon.github.io/tags/sql%E6%96%87%E4%BB%B6%E5%AF%BC%E5%87%BA%E5%92%8C%E5%AF%BC%E5%85%A5/"/>
    
      <category term="容器端口转发" scheme="https://peithon.github.io/tags/%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    
      <category term="Docker网络模式" scheme="https://peithon.github.io/tags/Docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核引发的Docker安装失败问题</title>
    <link href="https://peithon.github.io/2018/06/03/linux-kernel/"/>
    <id>https://peithon.github.io/2018/06/03/linux-kernel/</id>
    <published>2018-06-03T04:46:38.000Z</published>
    <updated>2018-10-13T00:02:28.359Z</updated>
    
    <content type="html"><![CDATA[<p>自己租了一个阿里云服务器，在上面搭建了docker环境，学习docker也有一段时间了，今天想在自己的CentOS7虚拟机中在安装一个docker，问题就随着出现了。这个问题花费了一些时间，不过最后总算解决了。<br><a id="more"></a></p><p>软件环境:</p><pre><code>操作系统: CentOS7内核版本：3.10.0-514其他：VMware14</code></pre><p>出现的问题：</p><pre><code>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>我的yum源都是换过的，没有使用CentOS7自带的yum源。替换成阿里云源了</p><p>Docker守护进程JSON配置文件: <code>/etc/docker/daemon.json</code></p><p>Docker守护进程数据保存目录: <code>/var/lib/docker</code></p><p>Docker守护进程日志: <code>/var/log/messages</code></p><p>Docker守护进程默认监听的Unix域套接字：<code>/var/run/docker.sock</code></p><h2 id="0x01-安装docker"><a href="#0x01-安装docker" class="headerlink" title="0x01 安装docker"></a>0x01 安装docker</h2><pre><code>[admin@localhost ~]$ sudo yum install -y docker[admin@localhost ~]$ docker -vDocker version 1.13.1, build 94f4240/1.13.1[admin@localhost ~]$ sudo docker infoCannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</code></pre><p>这个时候就出现了问题，百度Google了很多，都没有找到合适的解决办法。</p><h2 id="0x02-查看docker-daemon有没有运行"><a href="#0x02-查看docker-daemon有没有运行" class="headerlink" title="0x02 查看docker daemon有没有运行"></a>0x02 查看docker daemon有没有运行</h2><pre><code>[admin@localhost ~]$ ps aux | grep dockeradmin      4319  0.0  0.0 112664   972 pts/0    R+   18:57   0:00 grep --color=auto docker</code></pre><p>可以判断docker daemon是没有运行的</p><h2 id="0x03-手动启动守护程序"><a href="#0x03-手动启动守护程序" class="headerlink" title="0x03 手动启动守护程序"></a>0x03 手动启动守护程序</h2><pre><code>[admin@localhost log]$ dockerdINFO[0000] libcontainerd: new containerd process, pid: 4521 WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=4096INFO[0001] [graphdriver] using prior storage driver: overlay2 INFO[0001] Graph migration to content-addressability took 0.00 seconds INFO[0001] Loading containers: start.                   INFO[0001] Firewalld running: true                      INFO[0001] Default bridge (docker0) is assigned with an IP address 172.17.0.0/16. Daemon option --bip can be used to set a preferred IP address INFO[0001] Loading containers: done.                    WARN[0001] Not using native diff for overlay2, this may cause degraded performance for building images: opaque flag erroneously copied up, consider update to kernel 4.8 or later to fix WARN[0001] failed to retrieve docker-runc version: exec: &quot;docker-runc&quot;: executable file not found in $PATH WARN[0001] failed to retrieve docker-init version       INFO[0001] Daemon has completed initialization          INFO[0001] Docker daemon                                 commit=&quot;94f4240/1.13.1&quot; graphdriver=overlay2 version=1.13.1INFO[0001] API listen on /var/run/docker.sock           </code></pre><p>这些是之前的记录，然后再开一个终端，再次查看一遍信息，在新开的终端输入:<code>sudo docker info</code></p><p>新终端:</p><pre><code>Containers: 0 Running: 0 Paused: 0 Stopped: 0Images: 0Server Version: 1.13.1Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: falseLogging Driver: json-fileCgroup Driver: cgroupfsPlugins:  Volume: local Network: bridge host macvlan null overlaySwarm: inactiveRuntimes: runcDefault Runtime: runcInit Binary: docker-initcontainerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)runc version: N/A (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)init version: N/A (expected: 949e6facb77383876aeff8a6944dde66b3089574)Security Options: seccomp  Profile: defaultKernel Version: 3.10.0-514.el7.x86_64Operating System: CentOS Linux 7 (Core)OSType: linuxArchitecture: x86_64Number of Docker Hooks: 3CPUs: 1Total Memory: 976.5 MiBName: localhost.localdomainID: QA5O:XAFA:Y6MT:P7HC:HR6A:YFQ5:QITP:EDNR:6IMA:THF7:UKBE:CUD5Docker Root Dir: /var/lib/dockerDebug Mode (client): falseDebug Mode (server): falseRegistry: https://index.docker.io/v1/Experimental: falseInsecure Registries: 127.0.0.0/8Live Restore Enabled: falseRegistries: docker.io (secure)</code></pre><p>守护进程所在终端:</p><pre><code>INFO[0000] libcontainerd: new containerd process, pid: 4521 WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=4096INFO[0001] [graphdriver] using prior storage driver: overlay2 INFO[0001] Graph migration to content-addressability took 0.00 seconds INFO[0001] Loading containers: start.                   INFO[0001] Firewalld running: true                      INFO[0001] Default bridge (docker0) is assigned with an IP address 172.17.0.0/16. Daemon option --bip can be used to set a preferred IP address INFO[0001] Loading containers: done.                    WARN[0001] Not using native diff for overlay2, this may cause degraded performance for building images: opaque flag erroneously copied up, consider update to kernel 4.8 or later to fix WARN[0001] failed to retrieve docker-runc version: exec: &quot;docker-runc&quot;: executable file not found in $PATH WARN[0001] failed to retrieve docker-init version       INFO[0001] Daemon has completed initialization          INFO[0001] Docker daemon                                 commit=&quot;94f4240/1.13.1&quot; graphdriver=overlay2 version=1.13.1INFO[0001] API listen on /var/run/docker.sock           WARN[0050] failed to retrieve docker-runc version: exec: &quot;docker-runc&quot;: executable file not found in $PATH WARN[0050] failed to retrieve docker-init version  </code></pre><h2 id="0x04-查看日志"><a href="#0x04-查看日志" class="headerlink" title="0x04 查看日志"></a>0x04 查看日志</h2><pre><code>[admin@localhost ~]$ sudo cat /var/log/messagesMay 31 19:21:09 localhost dbus[660]: [system] Activating via systemd: service name=&apos;net.reactivated.Fprint&apos; unit=&apos;fprintd.service&apos;May 31 19:21:09 localhost dbus-daemon: dbus[660]: [system] Activating via systemd: service name=&apos;net.reactivated.Fprint&apos; unit=&apos;fprintd.service&apos;May 31 19:21:09 localhost systemd: Starting Fingerprint Authentication Daemon...May 31 19:21:09 localhost dbus[660]: [system] Successfully activated service &apos;net.reactivated.Fprint&apos;May 31 19:21:09 localhost dbus-daemon: dbus[660]: [system] Successfully activated service &apos;net.reactivated.Fprint&apos;May 31 19:21:09 localhost systemd: Started Fingerprint Authentication Daemon.May 31 19:21:09 localhost fprintd: Launching FprintObjectMay 31 19:21:09 localhost fprintd: ** Message: D-Bus service launched with name: net.reactivated.FprintMay 31 19:21:09 localhost fprintd: ** Message: entering main loopMay 31 19:21:39 localhost fprintd: ** Message: No devices in use, exit</code></pre><p>没有看出什么问题</p><h2 id="0x05-启动docker"><a href="#0x05-启动docker" class="headerlink" title="0x05 启动docker"></a>0x05 启动docker</h2><pre><code>$ systemctl start docker    //没有启动成功$ journalctl -xe-- Unit docker.service has begun starting up.6月 03 11:18:42 localhost.localdomain dockerd-current[50448]: time=&quot;2018-06-03T11:18:42.746059974+08:00&quot; level=info msg=&quot;libcontainerd: new containerd process, pid: 50453&quot;6月 03 11:18:44 localhost.localdomain dockerd-current[50448]: Error starting daemon: SELinux is not supported with the overlay2 graph driver on this kernel. Either boot into a new6月 03 11:18:44 localhost.localdomain systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE6月 03 11:18:44 localhost.localdomain systemd[1]: Failed to start Docker Application Container Engine.-- Subject: Unit docker.service has failed-- Defined-By: systemd-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel-- -- Unit docker.service has failed.-- -- The result is failed.6月 03 11:18:44 localhost.localdomain systemd[1]: Unit docker.service entered failed state.6月 03 11:18:44 localhost.localdomain systemd[1]: docker.service failed.6月 03 11:18:44 localhost.localdomain polkitd[648]: Unregistered Authentication Agent for unix-process:50367:23334872 (system bus name :1.1153, object path /org/freedesktop/Policy6月 03 11:19:07 localhost.localdomain fprintd[50383]: ** Message: No devices in use, exit</code></pre><p>SELinux不支持这个内核上的overlay2图形驱动程序，终于找到了问题所在，原来是内核不支持，我用的是3.10.0-514的内核，所以将内核升级就可以了</p><h2 id="0x06-升级内核—解决方法"><a href="#0x06-升级内核—解决方法" class="headerlink" title="0x06 升级内核—解决方法"></a>0x06 升级内核—解决方法</h2><p>1).导入ELRepo软件仓库的公共秘钥</p><pre><code>$ sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</code></pre><p>2).安装ELRepo软件仓库的yum源</p><pre><code>$ sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</code></pre><p>3).安装主线内核（ml=mainline）</p><pre><code>$ sudo yum --enablerepo=elrepo-kernel install kernel-ml</code></pre><p>4).重启系统</p><pre><code>$ reboot</code></pre><p>5).选择进入4.16.13-1.e17内核的系统</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-6-3/33522869.jpg" alt=""></p><p>6).查看内核以及docker信息</p><pre><code>$ uname -r$ systemctl start docker$ docker info</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-6-3/60446910.jpg" alt=""></p><p>现在docker就可以正常使用了</p><h2 id="0x07-出现该问题的因素"><a href="#0x07-出现该问题的因素" class="headerlink" title="0x07 出现该问题的因素"></a>0x07 出现该问题的因素</h2><h3 id="1-docker没有启动"><a href="#1-docker没有启动" class="headerlink" title="1.docker没有启动"></a>1.docker没有启动</h3><pre><code>$ systemctl start docker</code></pre><h3 id="2-该系统的内核不支持"><a href="#2-该系统的内核不支持" class="headerlink" title="2.该系统的内核不支持"></a>2.该系统的内核不支持</h3><pre><code>升级内核</code></pre><h3 id="3-用户没有管理docker的权限"><a href="#3-用户没有管理docker的权限" class="headerlink" title="3.用户没有管理docker的权限"></a>3.用户没有管理docker的权限</h3><pre><code>$ sudo docker info</code></pre><p>或者创建一个docker用户组，将该普通用户加入到docker组中，这样用户就可以管理docker了。</p><pre><code>$ sudo groupadd docker$ sudo usermod -aG docker admin</code></pre><p>目前所了解就这三个因素，如果有其他因素以后碰到会再来补充。</p><h2 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08 总结"></a>0x08 总结</h2><p>但是没有及时查看Docker的状态，这也是花费这么长时间的原因之一，还有就是对Docker的守护进程以及套接字之间理解的不是很好，所以出现问题才会没有清晰的排查思路，通过这次问题的解决，的确让我对Docker套接字还有守护进程之类的加深了理解。所以我相信，只要能够不断解决问题，在学习上就能学的更多，理解的更透彻。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己租了一个阿里云服务器，在上面搭建了docker环境，学习docker也有一段时间了，今天想在自己的CentOS7虚拟机中在安装一个docker，问题就随着出现了。这个问题花费了一些时间，不过最后总算解决了。&lt;br&gt;
    
    </summary>
    
      <category term="docker" scheme="https://peithon.github.io/categories/docker/"/>
    
    
      <category term="Linux内核" scheme="https://peithon.github.io/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
      <category term="CentOS7" scheme="https://peithon.github.io/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>ssh安全加固</title>
    <link href="https://peithon.github.io/2018/05/31/ssh-safety/"/>
    <id>https://peithon.github.io/2018/05/31/ssh-safety/</id>
    <published>2018-05-31T07:46:21.000Z</published>
    <updated>2018-10-13T00:03:10.087Z</updated>
    
    <content type="html"><![CDATA[<p>每一台服务器基本都会配置ssh服务，但是如果我们不对ssh进行安全防护，就相当于给入侵者提供了一个入侵途径。所以对ssh进行一些安全配置十分重要。<br><a id="more"></a></p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>ssh服务的配置文件:<code>/etc/ssh/sshd_config</code></p><p>ssh日志文件:<code>/var/log/secure</code></p><h2 id="0x01-更换ssh服务的端口"><a href="#0x01-更换ssh服务的端口" class="headerlink" title="0x01 更换ssh服务的端口"></a>0x01 更换ssh服务的端口</h2><p>ssh服务默认是22端口，修改的时候如果系统的SELinux是开启的话是不会成功的，会报以下的端口错误。</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-31/87667089.jpg" alt=""></p><p>因为SELinux开启时ssh不能在另一个端口运行</p><p>1).检查允许监听哪些端口sshd</p><pre><code>$ semanage port -l | grep sshssh_port_t                     tcp      22</code></pre><p>2).关闭SELinux或者添加一条规则</p><p>a.关闭SELinux</p><pre><code>$ sudo vi /etc/selinux/config#SELINUX=enforcing #注释掉#SELINUXTYPE=targeted #注释掉SELINUX=disabled #增加#保存退出</code></pre><p>执行命令使配置生效</p><pre><code>$ sudo setenforce 0</code></pre><p>b.添加规则</p><pre><code>$ sudo semanage port -a -t ssh_port_t -p tcp 30102</code></pre><p>若<code>semanage</code>命令不可以，使用命令<code>yum install -y policycoreutils-python</code>安装<code>policycoreutils-python</code>包</p><p>3).修改端口号(17行)</p><pre><code>$ sudo vi /etc/ssh/sshd_config 17  Port 30102</code></pre><p>4).重启ssh服务</p><pre><code>$ systemctl restart sshd</code></pre><p>5).测试30102是否可用</p><pre><code>$ ssh -p 30102 localhost</code></pre><p>6).在防火墙把22端口关闭</p><pre><code>$ sudo firewall-cmd --remove-port=22/tcp --permanent</code></pre><p>–permanent表示永久生效，重启不会丢失配置</p><p>7).重新加载配置</p><pre><code>$ sudo firewall-cmd --reload</code></pre><p>8).查看22端口的开放情况</p><pre><code>$ sudo firewall-cmd --query-port=22/tcpno</code></pre><p>9).防火墙开放30102端口</p><pre><code>$ sudo firewall-cmd --add-port=30102/tcp --permanent$ sudo firewall-cmd --reload$ systemctl restart sshd</code></pre><p>10).其他主机即可通过30102端口远程此电脑</p><pre><code>#查看开放的所有端口$ sudo firewall-cmd --zone=public --list-ports</code></pre><h2 id="0x02-改变ssh版本"><a href="#0x02-改变ssh版本" class="headerlink" title="0x02 改变ssh版本"></a>0x02 改变ssh版本</h2><p>目前存在两种SSH（版本1和版本2）。Red Hat Enterprise Linux下的OpenSSH套件使用SSH版本2，该版本具有增强的密钥交换算法，不易受到版本1中的攻击。修改配置文件第23行。</p><pre><code>23 Protocol 2</code></pre><h2 id="0x03-禁止root登录"><a href="#0x03-禁止root登录" class="headerlink" title="0x03 禁止root登录"></a>0x03 禁止root登录</h2><p>使用其他用户登录，这样既较低了用户权限，同时其他用户的账号攻击者还得猜解，这大大增加了攻击难度。修改配置文件49行</p><pre><code>49 PermitRootLogin no</code></pre><h2 id="0x04-通过密钥登录"><a href="#0x04-通过密钥登录" class="headerlink" title="0x04 通过密钥登录"></a>0x04 通过密钥登录</h2><p>不允许密码登录，利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。可以有效防止SSH暴力破解。如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。或者<a href="https://linux.cn/article-3725-1.html" target="_blank" rel="noopener">采用双因子认证</a>。 </p><pre><code>#修改配置文件77行,先允许密码登录，后面的步骤需要远程下载私钥文件$ sudo vi /etc/ssh/sshd_config77 PasswordAuthentication yes#允许密钥登录,54、55行54 RSAAuthentication yes55 PubkeyAuthentication yes#保存退出</code></pre><h3 id="1-制作密钥对"><a href="#1-制作密钥对" class="headerlink" title="1).制作密钥对"></a>1).制作密钥对</h3><p>密码登录到打算使用密钥登录的账户,建立密钥对</p><pre><code>$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/home/admin/.ssh/id_rsa):   回车Enter passphrase (empty for no passphrase):    输入密钥锁码，或直接按 Enter 留空Enter same passphrase again:    确认密钥锁码Your identification has been saved in /home/admin/.ssh/id_rsa.    &lt;== 私钥Your public key has been saved in /home/admin/.ssh/id_rsa.pub.    &lt;== 公钥The key fingerprint is:b7:af:ce:02:0d:d0:8d:64:80:11:13:1f:ed:c9:4f:5e admin@localhost.localdomainThe key&apos;s randomart image is:+--[ RSA 2048]----+|  ==o=oo         ||  .o.o+ .        ||    .+ .         ||      = . E      ||       *S..      ||      . +. .     ||       .  .      ||        .. .     ||         o+..    |+-----------------+</code></pre><p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</p><p>在admin用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥</p><h3 id="2-在服务器配置公钥"><a href="#2-在服务器配置公钥" class="headerlink" title="2).在服务器配置公钥"></a>2).在服务器配置公钥</h3><pre><code>$ cd .ssh$ cat id_rsa.pub &gt;&gt; authorized_keys$ chmod 600 authorized_keys$ chmod 700 ~/.ssh$systemctl restart sshd</code></pre><h3 id="3-下载密钥-id-rsa-文件到本地"><a href="#3-下载密钥-id-rsa-文件到本地" class="headerlink" title="3).下载密钥(id_rsa)文件到本地"></a>3).下载密钥(id_rsa)文件到本地</h3><h3 id="4-修改配置文件-不允许密码登录"><a href="#4-修改配置文件-不允许密码登录" class="headerlink" title="4).修改配置文件,不允许密码登录"></a>4).修改配置文件,不允许密码登录</h3><pre><code>$ sudo vi /etc/ssh/sshd_config77 PasswordAuthentication yes#保存退出$ systemctl restart sshd</code></pre><h3 id="5-使用Xshell远程连接"><a href="#5-使用Xshell远程连接" class="headerlink" title="5).使用Xshell远程连接"></a>5).使用Xshell远程连接</h3><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-31/35258433.jpg" alt=""></p><p>浏览-&gt;文件-&gt;选择id_rsa-&gt;输入密钥锁码-&gt;确认即可连接</p><h2 id="0x05-设置黑白名单"><a href="#0x05-设置黑白名单" class="headerlink" title="0x05 设置黑白名单"></a>0x05 设置黑白名单</h2><p>通过设置黑白名单可以限制访问,这样可以大大提高安全性</p><h3 id="限制用户"><a href="#限制用户" class="headerlink" title="限制用户"></a>限制用户</h3><h4 id="1-设置登录用户白名单"><a href="#1-设置登录用户白名单" class="headerlink" title="1).设置登录用户白名单"></a>1).设置登录用户白名单</h4><p>在<code>/etc/ssh/sshd_config</code>配置文件中设置AllowUsers选项</p><pre><code># 允许testadmin和从192.168.0.1 登录的test帐户通过SSH登录系统。AllowUsers    testadmin   test@192.168.0.1</code></pre><h4 id="2-设置登录用户黑名单"><a href="#2-设置登录用户黑名单" class="headerlink" title="2).设置登录用户黑名单"></a>2).设置登录用户黑名单</h4><p>在<code>/etc/ssh/sshd_config</code>配置文件中设置DenyUsers选项</p><pre><code>#不允许testadmin用户登录系统DenyUsers testadmin</code></pre><h3 id="限制IP"><a href="#限制IP" class="headerlink" title="限制IP"></a>限制IP</h3><h4 id="1-设置IP白名单"><a href="#1-设置IP白名单" class="headerlink" title="1).设置IP白名单"></a>1).设置IP白名单</h4><p>在<code>/etc/hosts.allow</code>中添加IP</p><pre><code>$ sudo vi /etc/hosts.allow## hosts.allow   This file contains access rules which are used to#               allow or deny connections to network services that#               either use the tcp_wrappers library or that have been#               started through a tcp_wrappers-enabled xinetd.##               See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos;#               for information on rule syntax.#               See &apos;man tcpd&apos; for information on tcp_wrapperssshd:192.168.0.1:allowsshd:192.168.0.1/24:allow</code></pre><p>在上面文件中添加了两个内容</p><pre><code>sshd:192.168.0.1:allow      #允许IP192.168.0.1登录sshsshd:192.168.0.1/24:allow   #允许192.168.0.1/24这段IP的用户登录ssh</code></pre><h4 id="2-设置IP黑名单"><a href="#2-设置IP黑名单" class="headerlink" title="2).设置IP黑名单"></a>2).设置IP黑名单</h4><pre><code>$ sudo vi /etc/hosts.deny## hosts.deny    This file contains access rules which are used to#               deny connections to network services that either use#               the tcp_wrappers library or that have been#               started through a tcp_wrappers-enabled xinetd.##               The rules in this file can also be set up in#               /etc/hosts.allow with a &apos;deny&apos; option instead.##               See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos;#               for information on rule syntax.#               See &apos;man tcpd&apos; for information on tcp_wrapperssshd:ALL    #拒绝全部的ssh登录</code></pre><h4 id="3-hosts-allow-和hosts-deny-两个文件同时设置规则的时候，hosts-allow-文件中的规则优先级高"><a href="#3-hosts-allow-和hosts-deny-两个文件同时设置规则的时候，hosts-allow-文件中的规则优先级高" class="headerlink" title="3).hosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高"></a>3).hosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高</h4><h2 id="0x06-设置多长时间没有成功连接上就断线"><a href="#0x06-设置多长时间没有成功连接上就断线" class="headerlink" title="0x06 设置多长时间没有成功连接上就断线"></a>0x06 设置多长时间没有成功连接上就断线</h2><p>默认的等待时间为 2 分钟，如果没有单位将以秒作为单位，可用的单位分别为 h，m、s，时间越短越安全。</p><pre><code>$ sudo vi /etc/ssh/sshd_config48 LoginGraceTime 30s#保存退出$systemctl restart sshd</code></pre><h2 id="0x07-配置Fail2ban、denyhosts等"><a href="#0x07-配置Fail2ban、denyhosts等" class="headerlink" title="0x07 配置Fail2ban、denyhosts等"></a>0x07 配置Fail2ban、denyhosts等</h2><p>当因为某些需要不得不使用密码登录时，使用Fail2ban可以缓解ssh服务器的暴力破解,通过配置Fail2ban来自动屏蔽针对SSH,HTTP等各服务的暴力密码猜解或者DDOS攻击等,降低暴力破解对服务器造成的威胁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一台服务器基本都会配置ssh服务，但是如果我们不对ssh进行安全防护，就相当于给入侵者提供了一个入侵途径。所以对ssh进行一些安全配置十分重要。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
    
      <category term="密钥登录" scheme="https://peithon.github.io/tags/%E5%AF%86%E9%92%A5%E7%99%BB%E5%BD%95/"/>
    
      <category term="ssh安全加固" scheme="https://peithon.github.io/tags/ssh%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA/"/>
    
  </entry>
  
  <entry>
    <title>使用源代码搭建LNMP动态网站</title>
    <link href="https://peithon.github.io/2018/05/28/lnmp-setup/"/>
    <id>https://peithon.github.io/2018/05/28/lnmp-setup/</id>
    <published>2018-05-28T09:27:33.000Z</published>
    <updated>2018-10-13T00:02:50.477Z</updated>
    
    <content type="html"><![CDATA[<p>想搭建一个练习平台，之前一直使用的是LAMP环境搭建的,使用的是yum仓库。这次想尝试使用LNMP来搭建，利用源代码安装，熟悉一下Nginx。<br><a id="more"></a></p><h2 id="0x00-更换yum源为阿里云源"><a href="#0x00-更换yum源为阿里云源" class="headerlink" title="0x00 更换yum源为阿里云源"></a>0x00 更换yum源为阿里云源</h2><p>1).备份原来的源</p><pre><code># mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</code></pre><p>2).下载新的源到/etc/yum.repos.d/目录下</p><pre><code># wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</code></pre><p>3)生成缓存</p><pre><code># yum makecache</code></pre><h2 id="0x01-安装编译程序源码的环境"><a href="#0x01-安装编译程序源码的环境" class="headerlink" title="0x01 安装编译程序源码的环境"></a>0x01 安装编译程序源码的环境</h2><pre><code># yum install -y apr* autoconf automake bison bzip2 bzip2* compat* cpp curl curl-devel fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtiff libtiff* make mpfr ncurses* ntp openssl openssl-devel patch pcre-devel perl php-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel</code></pre><h2 id="0x02-下载搭建LNMP所需的软件包"><a href="#0x02-下载搭建LNMP所需的软件包" class="headerlink" title="0x02 下载搭建LNMP所需的软件包"></a>0x02 下载搭建LNMP所需的软件包</h2><pre><code># cd /usr/local/src</code></pre><p>通过<a href="https://pan.baidu.com/s/1w2TDjsicsH0nABD816XpeA" target="_blank" rel="noopener">百度云链接下载</a>，将软件包放到该目录下</p><h2 id="0x03-安装CMake"><a href="#0x03-安装CMake" class="headerlink" title="0x03 安装CMake"></a>0x03 安装CMake</h2><p>1).解压tar包</p><pre><code># tar xzvf cmake-2.8.11.2.tar.gz   </code></pre><p>2).进入cmake-2.8.11.2目录,并执行安装  </p><pre><code># cd cmake-2.8.11.2/                       # ./configure                               </code></pre><p>3).编译源代码生成可执行文件</p><pre><code># make  </code></pre><p>4).安装编译成功的可执行文件，一般目录在/usr/local/bin下</p><pre><code># make install                             </code></pre><p>CMake是Linux系统下常用的编译工具，因为使用源码包安装编译时需要用到，所以先安装，通常源码安装四个步骤</p><pre><code>1).下载及解压源码包文件2).编译源码包代码3).生成二进制安装程序4).运行二进制的服务程序安装包</code></pre><h2 id="0x04-安装MYSQL数据库"><a href="#0x04-安装MYSQL数据库" class="headerlink" title="0x04 安装MYSQL数据库"></a>0x04 安装MYSQL数据库</h2><p>在系统中创建一个名为sqladmin的用户，专门用于负责运行MySQL数据库。并把该账户的Bash终端设置成nologin解释器，提高系统的安全性。</p><p>回到/usr/local/src目录下</p><p>1).添加本地用户sqladmin,设置shell为nologin</p><pre><code># useradd mysql -s /sbin/nologin</code></pre><p>2).创建目录用于保存MySQL数据库有关文件</p><pre><code># mkdir -p /usr/local/mysql/var</code></pre><p>3).将该目录的所有者和所属组身份修改为sqladmin</p><pre><code># chown -Rf mysql:mysql /usr/local/mysql</code></pre><p>4).解压MySQL源代码tar包</p><pre><code># tar xzvf mysql-5.6.19.tar.gz</code></pre><p>5).编译数据库</p><pre><code># cd mysql-5.6.19/# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/var -DSYSCONFDIR=/etc各参数意义:-DCMAKE_INSTALL_PREFIX    用于定义数据库服务程序的保存目录-DMYSQL_DATADIR           用于定义真实数据库文件的目录-DSYSCONFDIR              定义MySQL数据库配置文件的保存目录</code></pre><p>6).编译源代码生成二可执行文件</p><pre><code># make</code></pre><p>7).安装可执行程序</p><pre><code># make install</code></pre><p>8).删除/etc目录中的mysql的默认配置文件</p><pre><code># rm -rf /etc/my.cnf</code></pre><p>9).进入数据库服务程序的保存目录</p><p>在scripts内找到一个名为mysql_install_db的脚本程序，并执行这个脚本程序</p><pre><code># cd /usr/local/mysql# ./scripts/mysql_install_db --user=sqladmin --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var</code></pre><p>10).新生成的MySQL数据库配置文件链接到/etc目录中</p><pre><code># ln -s my.cnf /etc/my.cnf</code></pre><p>11).程序目录中的开机程序文件复制到/etc/rc.d/init.d目录中</p><pre><code>#  cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld</code></pre><p>12).修改数据库脚本权限</p><pre><code># chmod 755 /etc/rc.d/init.d/mysqld</code></pre><p>13).修改MySQL数据库的脚本文件</p><pre><code># vi /etc/rc.d/init.d/mysqld </code></pre><p>命令模式输入”:set nu”显示所有行数,填入信息</p><pre><code> 46 basedir=/usr/local/mysql 47 datadir=/usr/local/mysql/var#保存退出</code></pre><p>14).启动数据库</p><pre><code># service mysqld start</code></pre><p>启动数据库出现问题：</p><pre><code>Starting MySQL. ERROR! The server quit without updating PID file (/usr/local/mysql/var/localhost.localdomain.pid).</code></pre><p>解决过程：</p><pre><code>刚开始我以为是没有localhost.localdomain.pid,所以我建了这个文件，然后发现当我想启动mysql时，新建的.pid文件就消失了卧榻，网上Google了半天各种办法都试过了也没解决，回头看到一个localhost.localdomain.err文件，打开看到一行关键信息119563 [ERROR] Fatal error: Can&apos;t change to run as user &apos;mysql&apos; ;  Please check that the user exists!原来是没有mysql这个用户，赶紧把之前建的sqladmin用户删除了，新建了mysql用户，并重修修改了mysql文件的所有者和权限并且把前面的步骤内容更改了一下，但是问题记录了下来，localhost.localdomain.err文件路径:/usr/local/mysql/var/localhost.localdomain.err</code></pre><p>解决问题的步骤：</p><pre><code># userdel sqladmin(之前新建的sqlamdin用户)# useradd mysql -s /sbin/nologin# chown -Rf mysql:mysql /usr/local/mysql# service mysqld start#然后数据库启动成功,可以进行下一步安装</code></pre><p>15.将MySQL服务设置开机启动</p><pre><code># chkconfig mysqld on</code></pre><p>16.编辑/etc/profile文件将命令所保存的目录永久性地定义到PATH变量</p><p>mysql数据库自带了许多命令，但是Bash终端的PATH变量并不包含这些命令所在的目录，所以需要自己添加，这样当物理设备在下一次重启时就会永久生效了。使用source命令加载一下/ect/profile文件，此时新的PATH变量也可以立即生效了。</p><pre><code># vi /etc/profile</code></pre><p>使用”:set nu”命令查看所有行数，在47行添加</p><pre><code>export PATH=$PATH:/usr/local/mysql/bin</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/51351698.jpg" alt=""></p><pre><code># source /etc/profile</code></pre><p>17.初始化MySQL数据库</p><pre><code># mysql_secure_installation </code></pre><p>设置参数如下</p><pre><code>NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!In order to log into MySQL to secure it, we&apos;ll need the currentpassword for the root user.  If you&apos;ve just installed MySQL, andyou haven&apos;t set the root password yet, the password will be blank,so you should just press enter here.Enter current password for root (enter for none): 回车OK, successfully used password, moving on...Setting the root password ensures that nobody can log into the MySQLroot user without the proper authorisation.Set root password? [Y/n] y（为数据库管理员root设置密码）New password: 输入密码Re-enter new password: 确认密码Password updated successfully!Reloading privilege tables.. ... Success!By default, a MySQL installation has an anonymous user, allowing anyoneto log into MySQL without having to have a user account created forthem.  This is intended only for testing, and to make the installationgo a bit smoother.  You should remove them before moving into aproduction environment.Remove anonymous users? [Y/n] y   （删除匿名用户） ... Success!Normally, root should only be allowed to connect from &apos;localhost&apos;.  Thisensures that someone cannot guess at the root password from the network.Disallow root login remotely? [Y/n] y   （禁止root远程登录） ... Success!By default, MySQL comes with a database named &apos;test&apos; that anyone canaccess.  This is also intended only for testing, and should be removedbefore moving into a production environment.Remove test database and access to it? [Y/n] y   （删除test数据库并取消对其的访问权限） - Dropping test database... ... Success! - Removing privileges on test database... ... Success!Reloading the privilege tables will ensure that all changes made so farwill take effect immediately.Reload privilege tables now? [Y/n] y   （刷新授权，让初始化立即生效） ... Success!All done!  If you&apos;ve completed all of the above steps, your MySQLinstallation should now be secure.Thanks for using MySQL!Cleaning up...</code></pre><h2 id="0x05-配置Nginx服务"><a href="#0x05-配置Nginx服务" class="headerlink" title="0x05 配置Nginx服务"></a>0x05 配置Nginx服务</h2><h3 id="安装Nginx所需的依赖包"><a href="#安装Nginx所需的依赖包" class="headerlink" title="安装Nginx所需的依赖包"></a>安装Nginx所需的依赖包</h3><h5 id="1-安装pcre包"><a href="#1-安装pcre包" class="headerlink" title="1.安装pcre包"></a>1.安装pcre包</h5><p>软件包pcre是Nginx服务程序用于实现伪静态功能必不可少的依赖包</p><p>1).进入/usr/local/src目录，解压tar包</p><pre><code># tar xzvf pcre-8.35.tar.gz </code></pre><p>2).进入pcre目录，编译</p><pre><code># cd pcre-8.35# ./configure --prefix=/usr/local/pcre</code></pre><p>3).生成可执行文件</p><pre><code># make</code></pre><p>4).执行</p><pre><code># make install</code></pre><h5 id="2-安装openssl包"><a href="#2-安装openssl包" class="headerlink" title="2.安装openssl包"></a>2.安装openssl包</h5><p>openssl软件包是用于提供网站加密证书服务的程序文件，在安装该程序时需要自定义服务程序的安装目录，以便于稍后调用它们的时候更可控。</p><pre><code># cd /usr/local/src# tar xzvf pcre-8.35.tar.gz# cd pcre-8.35# ./configure --prefix=/usr/local/pcre# make# make install</code></pre><p>配置openssl的配置文件，将命令目录添加到PATH环境变量中去,使用source命令让它立即生效</p><pre><code># vi /etc/profile</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/20181852.jpg" alt=""></p><pre><code># source /etc/profile</code></pre><h5 id="3-安装zlib包"><a href="#3-安装zlib包" class="headerlink" title="3.安装zlib包"></a>3.安装zlib包</h5><p>zlib软件包是用于提供压缩功能的函数库文件</p><pre><code># cd /usr/local/src# tar xzvf zlib-1.2.8.tar.gz # cd zlib-1.2.8# ./configure --prefix=/usr/local/zlib# make# make install</code></pre><h3 id="创建执行Nginx服务程序的账号"><a href="#创建执行Nginx服务程序的账号" class="headerlink" title="创建执行Nginx服务程序的账号"></a>创建执行Nginx服务程序的账号</h3><pre><code># cd /usr/local/src# useradd www -s /sbin/nologin</code></pre><h3 id="安装Nginx服务器"><a href="#安装Nginx服务器" class="headerlink" title="安装Nginx服务器"></a>安装Nginx服务器</h3><pre><code># tar xzvf nginx-1.6.0.tar.gz# cd nginx-1.6.0/# ./configure --prefix=/usr/local/nginx --without-http_memcached_module --user=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-openssl=/usr/local/src/openssl-1.0.1h --with-zlib=/usr/local/src/zlib-1.2.8 --with-pcre=/usr/local/src/pcre-8.35# make# make install</code></pre><p>参数意义：</p><ul><li>–prefix参数用于定义服务程序稍后安装到的位置</li><li>–user与–group参数用于指定执行Nginx服务程序的用户名和用户组</li><li>在使用参数调用openssl、zlib、pcre软件包时，写出软件源码包的解压路径，而不是程序的安装路径</li></ul><h3 id="将Nginx设置到开机启动项中"><a href="#将Nginx设置到开机启动项中" class="headerlink" title="将Nginx设置到开机启动项中"></a>将Nginx设置到开机启动项中</h3><pre><code># vi /etc/rc.d/init.d/nginx</code></pre><p>配置脚本文件(因为没有nginx这个文件，直接copy就好)</p><pre><code>#!/bin/bash# nginx - this script starts and stops the nginx daemon# chkconfig: - 85 15# description: Nginx is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /usr/local/nginx/conf/nginx.conf# pidfile: /usr/local/nginx/logs/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0nginx=&quot;/usr/local/nginx/sbin/nginx&quot;prog=$(basename $nginx)NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot;[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() {# make required directoriesuser=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &apos;s/[^*]*--user=\([^ ]*\).*/\1/g&apos; -`        if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then                useradd -M -s /bin/nologin $user        fioptions=`$nginx -V 2&gt;&amp;1 | grep &apos;configure arguments:&apos;`for opt in $options; do        if [ `echo $opt | grep &apos;.*-temp-path&apos;` ]; then                value=`echo $opt | cut -d &quot;=&quot; -f 2`                if [ ! -d &quot;$value&quot; ]; then                        # echo &quot;creating&quot; $value                        mkdir -p $value &amp;&amp; chown -R $user $value                fi        fidone}start() {[ -x $nginx ] || exit 5[ -f $NGINX_CONF_FILE ] || exit 6make_dirsecho -n $&quot;Starting $prog: &quot;daemon $nginx -c $NGINX_CONF_FILEretval=$?echo[ $retval -eq 0 ] &amp;&amp; touch $lockfilereturn $retval}stop() {echo -n $&quot;Stopping $prog: &quot;killproc $prog -QUITretval=$?echo[ $retval -eq 0 ] &amp;&amp; rm -f $lockfilereturn $retval}restart() {#configtest || return $?stopsleep 1start}reload() {#configtest || return $?echo -n $&quot;Reloading $prog: &quot;killproc $nginx -HUPRETVAL=$?echo}force_reload() {restart}configtest() {$nginx -t -c $NGINX_CONF_FILE}rh_status() {status $prog}rh_status_q() {rh_status &gt;/dev/null 2&gt;&amp;1}case &quot;$1&quot; instart)        rh_status_q &amp;&amp; exit 0        $1        ;;stop)        rh_status_q || exit 0        $1        ;;restart|configtest)$1;;reload)        rh_status_q || exit 7        $1        ;;force-reload)        force_reload        ;;status)        rh_status        ;;condrestart|try-restart)        rh_status_q || exit 0        ;;*)echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot;exit 2esac#保存退出</code></pre><h3 id="为脚本赋予755权限，然后使用chkconfig命令添加服务到开机启动项"><a href="#为脚本赋予755权限，然后使用chkconfig命令添加服务到开机启动项" class="headerlink" title="为脚本赋予755权限，然后使用chkconfig命令添加服务到开机启动项"></a>为脚本赋予755权限，然后使用chkconfig命令添加服务到开机启动项</h3><pre><code># chmod 755 /etc/rc.d/init.d/nginx# /etc/rc.d/init.d/nginx restart    //以绝对路径执行该脚本状态：Reloading systemd:                                         [  确定  ]Restarting nginx (via systemctl):                          [  确定  ]在nginx-1.6.0目录下root@localhost nginx-1.6.0]# chkconfig nginx on</code></pre><h3 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h3><pre><code># elinks 服务器ip</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/47149746.jpg" alt=""></p><h2 id="0x06-配置PHP服务"><a href="#0x06-配置PHP服务" class="headerlink" title="0x06 配置PHP服务"></a>0x06 配置PHP服务</h2><p>php具有开源、免费、快捷、跨平台性强、效率高等优良特性，是目前Web开发领域最常用的语言之一,安装php比安装Nginx还要复杂，得先安装很多依赖包，所以用源码包安装LNMP环境特别耗费时间</p><h3 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h3><h5 id="1-安装yasm包"><a href="#1-安装yasm包" class="headerlink" title="1.安装yasm包"></a>1.安装yasm包</h5><p>yasm源码包是一款常见的开源汇编器</p><pre><code># cd /usr/local/src# tar zxvf yasm-1.2.0.tar.gz# cd yasm-1.2.0# ./configure# make# make install</code></pre><h5 id="2-安装libmcrypt包"><a href="#2-安装libmcrypt包" class="headerlink" title="2.安装libmcrypt包"></a>2.安装libmcrypt包</h5><p>libmcrypt源码包是用于加密算法的扩展库程序</p><pre><code># cd /usr/local/src# tar zxvf libmcrypt-2.5.8.tar.gz# cd libmcrypt-2.5.8# ./configure# make# make install</code></pre><h5 id="3-安装libvpx包"><a href="#3-安装libvpx包" class="headerlink" title="3.安装libvpx包"></a>3.安装libvpx包</h5><p>libvpx源码包是用于提供视频编码器的服务程序</p><pre><code># cd /usr/local/src# tar xjvf libvpx-v1.3.0.tar.bz2# cd libvpx-v1.3.0# ./configure --prefix=/usr/local/libvpx --enable-shared --enable-vp9# make# make install</code></pre><h5 id="4-安装tiff包"><a href="#4-安装tiff包" class="headerlink" title="4.安装tiff包"></a>4.安装tiff包</h5><p>tiff源码包是用于提供标签图像文件格式的服务程序</p><pre><code># tar zxvf tiff-4.0.3.tar.gz# cd tiff-4.0.3# ./configure --prefix=/usr/local/tiff --enable-shared# make# make install</code></pre><h5 id="5-安装libpng包"><a href="#5-安装libpng包" class="headerlink" title="5.安装libpng包"></a>5.安装libpng包</h5><p>libpng源码包是用于提供png图片格式支持函数库的服务程序</p><pre><code># cd /usr/local/src# tar zxvf libpng-1.6.12.tar.gz# cd libpng-1.6.12# ./configure --prefix=/usr/local/libpng --enable-shared# make# make install</code></pre><h5 id="6-安装freetype包"><a href="#6-安装freetype包" class="headerlink" title="6.安装freetype包"></a>6.安装freetype包</h5><p>freetype源码包是用于提供字体支持引擎的服务程序</p><pre><code># cd /usr/local/src# tar zxvf freetype-2.5.3.tar.gz# cd freetype-2.5.3# ./configure --prefix=/usr/local/freetype --enable-shared# make# make install</code></pre><h5 id="7-安装jpeg包"><a href="#7-安装jpeg包" class="headerlink" title="7.安装jpeg包"></a>7.安装jpeg包</h5><p>jpeg源码包是用于提供jpeg图片格式支持函数库的服务程序</p><pre><code># cd /usr/local/src# tar zxvf jpegsrc.v9a.tar.gz# cd jpeg-9a# ./configure --prefix=/usr/local/jpeg --enable-shared# mkae# make install</code></pre><h5 id="8-安装libgd包"><a href="#8-安装libgd包" class="headerlink" title="8.安装libgd包"></a>8.安装libgd包</h5><p>libgd源码包是用于提供图形处理的服务程序，编译时要写入jpeg、libpng、freetype、tiff、libvpx等服务程序在系统中的安装路径</p><pre><code># cd ..# tar zxvf libgd-2.1.0.tar.gz# ./configure --prefix=/usr/local/libgd --enable-shared --with-jpeg=/usr/local/jpeg --with-png=/usr/local/libpng --with-freetype=/usr/local/freetype --with-fontconfig=/usr/local/freetype --with-xpm=/usr/ --with-tiff=/usr/local/tiff --with-vpx=/usr/local/libvpx# make# make install</code></pre><h5 id="9-安装t1lib包"><a href="#9-安装t1lib包" class="headerlink" title="9.安装t1lib包"></a>9.安装t1lib包</h5><p>t1lib源码包是用于提供图片生成函数库的服务程序</p><pre><code># cd ..# tar zxvf t1lib-5.1.2.tar.gz# cd t1lib-5.1.2# ./configure --prefix=/usr/local/t1lib --enable-shared# make# make install# ln -s /usr/lib64/libltdl.so /usr/lib/libltdl.so # cp -frp /usr/lib64/libXpm.so* /usr/lib/</code></pre><h3 id="安装php服务"><a href="#安装php服务" class="headerlink" title="安装php服务"></a>安装php服务</h3><p>在开始编译php源码包之前，先定义一个名为LD_LIBRARY_PATH的全局环境变量，该环境变量的作用是帮助系统找到指定的动态链接库文件，这些文件是编译php服务源码包的必须元素之一。编译php服务源码包时，除了定义要安装到的目录以外，还需要依次定义配置php服务程序配置文件的保存目录、MySQL数据库服务程序所在目录、MySQL数据库服务程序配置文件所在目录，以及libpng、jpeg、freetype、libvpx、zlib、t1lib等服务程序的安装目录路径，并通过参数启动php服务程序的诸多默认功能</p><pre><code># cd ..# tar -zvxf php-5.5.14.tar.gz# cd php-5.5.14# export LD_LIBRARY_PATH=/usr/local/libgd/lib# ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql --with-mysqli=/usr/local/mysql/bin/mysql_config --with-mysql-sock=/tmp/mysql.sock --with-pdo-mysql=/usr/local/mysql --with-gd --with-png-dir=/usr/local/libpng --with-jpeg-dir=/usr/local/jpeg --with-freetype-dir=/usr/local/freetype --with-xpm-dir=/usr/ --with-vpx-dir=/usr/local/libvpx/ --with-zlib-dir=/usr/local/zlib --with-t1lib=/usr/local/t1lib --with-iconv --enable-libxml --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-opcache --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-mcrypt --with-curl --enable-ctype# make# make install</code></pre><h3 id="修改php配置文件"><a href="#修改php配置文件" class="headerlink" title="修改php配置文件"></a>修改php配置文件</h3><pre><code># rm -rf /etc/php.ini# ln -s /usr/local/php/etc/php.ini /etc/php.ini# cp php.ini-production /usr/local/php/etc/php.ini# cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf# ln -s /usr/local/php/etc/php-fpm.conf /etc/php-fpm.conf</code></pre><h3 id="修改php-fpm-conf文件"><a href="#修改php-fpm-conf文件" class="headerlink" title="修改php-fpm.conf文件"></a>修改php-fpm.conf文件</h3><p>分别将第148和149行的user与group参数分别修改为www账户和用户组名称</p><pre><code># vi /usr/local/php/etc/php-fpm.conf</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/61643236.jpg" alt=""></p><h3 id="把php-fpm服务程序加入到开机启动项"><a href="#把php-fpm服务程序加入到开机启动项" class="headerlink" title="把php-fpm服务程序加入到开机启动项"></a>把php-fpm服务程序加入到开机启动项</h3><p>为了能够执行脚本，为脚本赋予755权限。</p><pre><code># cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm# chmod 755 /etc/rc.d/init.d/php-fpm# chkconfig php-fpm on</code></pre><h3 id="修改php-ini配置文件"><a href="#修改php-ini配置文件" class="headerlink" title="修改php.ini配置文件"></a>修改php.ini配置文件</h3><p>在305行的disable_functions参数后面追加上要禁止的功能</p><pre><code># vi /usr/local/php/etc/php.ini</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/83415991.jpg" alt=""></p><h2 id="0x07-修改Nginx配置文件"><a href="#0x07-修改Nginx配置文件" class="headerlink" title="0x07 修改Nginx配置文件"></a>0x07 修改Nginx配置文件</h2><pre><code># vi /usr/local/nginx/conf/nginx.conf</code></pre><p>把第2行的注释删除，然后在后面写上负责运行Nginx服务程序的账户名称和用户组名称</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/93653711.jpg" alt=""></p><p>在第45行的index参数后面写上网站的首页名称</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/52311967.jpg" alt=""></p><p>将第65～71行参数前的注释删除来启用参数，主要是修改第69行的脚本名称路径参数，其中$document_root变量即为网站信息存储的根目录路径，若没有设置该变量，则Nginx服务程序无法找到网站信息，因此会提示“404页面未找到”的报错信息</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/73622794.jpg" alt=""></p><p>在确认参数信息填写正确后便可重启Nginx服务与php-fpm服务</p><h2 id="0x08-重启服务"><a href="#0x08-重启服务" class="headerlink" title="0x08 重启服务"></a>0x08 重启服务</h2><pre><code># systemctl restart nginx# systemctl restart php-fpm</code></pre><p>到了这一步LNMP环境就搭建完成了</p><h2 id="0x09-测试"><a href="#0x09-测试" class="headerlink" title="0x09 测试"></a>0x09 测试</h2><p>为了测试LNMP环境搭建是否妥当，部署Discuz!系统</p><p>1).解压dz</p><pre><code># cd /usr/local/src/# unzip Discuz_X3.2_SC_GBK.zip</code></pre><p>2).将文件放在服务器目录</p><p>解压后会在当前目录中出现一个名为upload的文件目录，这里面保存的就是Discuz！论坛的系统程序。把Nginx服务程序网站根目录的内容清空后，就可以把这些这个目录中的文件都复制进去</p><pre><code># # rm -rf /usr/local/nginx/html/{index.html,50x.html}*# mv upload/* /usr/local/nginx/html/</code></pre><p>3).修改属主和权限</p><p>把Nginx服务程序的网站根目录的所有者和所属组修改为本地的www用户,并赋予755权限以便于能够读、写、执行该论坛系统内的文件</p><pre><code># chown -Rf www:www /usr/local/nginx/html# chmod -Rf 755 /usr/local/nginx/html</code></pre><p>4).在浏览器输入http://服务器ip/install/,开始安装</p><p>5).确保当前状态都是可写，然后进行下一步</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/53416616.jpg" alt=""></p><p>6).选择“全新安装Discuz! X（含UCenter Server）”,后面填写要求的信息</p><p>7).安装成功，说明</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/18-5-28/71975436.jpg" alt=""></p><p>既然环境没有问题.接下就是搭建练习平台了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想搭建一个练习平台，之前一直使用的是LAMP环境搭建的,使用的是yum仓库。这次想尝试使用LNMP来搭建，利用源代码安装，熟悉一下Nginx。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
    
      <category term="lnmp搭建" scheme="https://peithon.github.io/tags/lnmp%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7下部署KVM以及virsh常用命令</title>
    <link href="https://peithon.github.io/2018/05/25/kvm-deploy/"/>
    <id>https://peithon.github.io/2018/05/25/kvm-deploy/</id>
    <published>2018-05-25T02:38:25.000Z</published>
    <updated>2018-10-13T00:01:56.198Z</updated>
    
    <content type="html"><![CDATA[<p>KVM(Kernel Virtual Modle)能够提供像Vmware一样的全虚拟化功能,我们可以通过KVM虚拟机制作qcow2镜像，用于openstack环境中。</p><a id="more"></a><h2 id="0x00-检测CPU支不支持虚拟化"><a href="#0x00-检测CPU支不支持虚拟化" class="headerlink" title="0x00 检测CPU支不支持虚拟化"></a>0x00 检测CPU支不支持虚拟化</h2><pre><code># egrep -o &apos;(vmx|svm)&apos; /proc/cpuinfo</code></pre><p>输出vmx的值说明是支持的,没有的话到Vmware开启</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm0-1.png" alt=""></p><h2 id="0x01-安装KVM以及相关依赖包"><a href="#0x01-安装KVM以及相关依赖包" class="headerlink" title="0x01 安装KVM以及相关依赖包"></a>0x01 安装KVM以及相关依赖包</h2><pre><code># yum -y groupinstall &quot;Virtualization Host&quot;# yum -y install virt-{install,viewer,manager}</code></pre><h2 id="0x02-配置网络，让KVM中虚拟机能共享网络"><a href="#0x02-配置网络，让KVM中虚拟机能共享网络" class="headerlink" title="0x02 配置网络，让KVM中虚拟机能共享网络"></a>0x02 配置网络，让KVM中虚拟机能共享网络</h2><p>1).让系统支持ipv4的转发功能</p><pre><code># echo &quot;net.ipv4.ip_forward = 1&quot; &gt; /etc/sysctl.d/99-ipforward.conf</code></pre><p>2).让转发功能立即生效</p><pre><code># sysctl -p /etc/sysctl.d/99-ipforward.conf</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm1.png" alt=""></p><h2 id="0x03-检查kvm模块是否被加载"><a href="#0x03-检查kvm模块是否被加载" class="headerlink" title="0x03 检查kvm模块是否被加载"></a>0x03 检查kvm模块是否被加载</h2><pre><code># lsmod | grep kvm</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm3.png" alt=""></p><h2 id="0x04-禁用并卸载NetworkManager工具-必要-，启用自带的network服务"><a href="#0x04-禁用并卸载NetworkManager工具-必要-，启用自带的network服务" class="headerlink" title="0x04 禁用并卸载NetworkManager工具(必要)，启用自带的network服务"></a>0x04 禁用并卸载NetworkManager工具(必要)，启用自带的network服务</h2><pre><code># chkconfig NetworkManager off# chkconfig network on# service NetworkManager stop# yum erase NetworkManager</code></pre><h2 id="0x05-设置网卡为桥接模式"><a href="#0x05-设置网卡为桥接模式" class="headerlink" title="0x05 设置网卡为桥接模式"></a>0x05 设置网卡为桥接模式</h2><p>使用”ip link show”查看网卡的Mac地址</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm2.png" alt=""></p><pre><code># cp /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens33.bak# vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><p>编辑网卡配置文件，将ip等信息注释后追加参数BRIDGE=br0</p><pre><code>TYPE=EthernetBOOTPROTO=staticDEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=c0d6a6b8-de69-45ff-86ae-1b4865250a27DEVICE=ens33ONBOOT=yes#DNS1=114.114.114.114#IPADDR=10.203.87.111#PREFIX=32#GATEWAY=10.203.87.254IPV6_PEERDNS=yesIPV6_PEERROUTES=yesBRIDGE=&quot;br0&quot;#保存退出</code></pre><h2 id="0x06-创建用于桥接网卡的配置文件"><a href="#0x06-创建用于桥接网卡的配置文件" class="headerlink" title="0x06 创建用于桥接网卡的配置文件"></a>0x06 创建用于桥接网卡的配置文件</h2><pre><code>#  vi /etc/sysconfig/network-scripts/ifcfg-br0</code></pre><p>添加以下内容</p><pre><code>DEVICE=&quot;br0&quot;TYPE=BRIDGEONBOOT=yesBOOTPROTO=staticIPADDR=&quot;10.203.87.111&quot;NETMASK=&quot;255.255.255.0&quot;GATEWAY=&quot;10.203.87.254&quot;DNS1=&quot;114.114.114.114&quot;#保存退出</code></pre><h2 id="0x07-重启网络"><a href="#0x07-重启网络" class="headerlink" title="0x07 重启网络"></a>0x07 重启网络</h2><pre><code># /etc/init.d/network restart</code></pre><p>要是出问题就直接重启系统(reboot)或者执行以下命令</p><pre><code># ifdown br0# ifdown ens33# ifup br0# ifup ens33</code></pre><h2 id="0x08-查看路由及网卡桥接"><a href="#0x08-查看路由及网卡桥接" class="headerlink" title="0x08 查看路由及网卡桥接"></a>0x08 查看路由及网卡桥接</h2><pre><code># route# brctl show</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm5.png" alt=""></p><pre><code># ifconfig</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm6.png" alt=""></p><p>这样就把ens33桥接为br0网卡了,KVM就可以使用这个桥接配置了</p><h2 id="0x09-获取虚拟机列表"><a href="#0x09-获取虚拟机列表" class="headerlink" title="0x09 获取虚拟机列表"></a>0x09 获取虚拟机列表</h2><pre><code># virsh -c qemu:///system list</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm4.png" alt=""></p><p>或者使用”virsh  list –all”查看</p><p>现在还没有安装虚拟机，所以列表是空的</p><h2 id="0x10-配置虚拟机"><a href="#0x10-配置虚拟机" class="headerlink" title="0x10 配置虚拟机"></a>0x10 配置虚拟机</h2><p>1).设置语言环境</p><pre><code># vi /etc/locale.conf</code></pre><p>语言设为英文LANG=”en_US.UTF-8”</p><p>2).创建安装盘</p><pre><code># qemu-img create -f qcow2 /kvmtest/Centos-7.qcow2 8G</code></pre><p>3).创建虚拟机</p><pre><code># virt-install --virt-type kvm --name centos-7.0 --ram 1024 \  --vcpus 1 \  --cdrom=/kvmtest/CentOS-7-x86_64-DVD-1611.iso \  --disk path=/kvmtest/Centos-7.qcow2,size=8,format=qcow2 \  --network bridge=br0 \  --graphics vnc,listen=0.0.0.0 --noautoconsole \  --os-type=linux --os-variant=rhel6</code></pre><hr><p>各个参数的意义：</p><pre><code>--name               虚拟机名称--vcpus              虚拟机虚拟CPU个数--ram                 虚拟机内存--disk                虚拟机使用的磁盘路径--network            网络设置--cdrom                设置光驱获取虚拟光驱文件的路径--os-variant        指示为特定的操作系统版本</code></pre><p>4).使用”virsh list –all”查看</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm7.png" alt=""></p><p>然后执行命令”virt-manager”就会发现有虚拟机在安装，选中centos-7.0，点击Open，然后就开始进行图形界面安装吧,和安装虚拟机的步骤一样。</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm8.PNG" alt=""></p><h1 id="0x11-KVM-virsh常用命令"><a href="#0x11-KVM-virsh常用命令" class="headerlink" title="0x11 KVM virsh常用命令"></a>0x11 KVM virsh常用命令</h1><p>1.列出全部虚拟机</p><pre><code># virsh list --all</code></pre><p>2.启动虚拟机</p><pre><code># virsh start centos-7.0    //列出的name列</code></pre><p>3.进入虚拟机</p><pre><code># virsh console centos-7.0</code></pre><p>4.退出虚拟机</p><pre><code>CTRL+]</code></pre><p>5.关闭虚拟机</p><pre><code># virsh shutdown centos-7.0</code></pre><p>刚开始是不可以关闭的，因为还没有安装acpid服务，它是linux内核与应用程序之间的通信接口，负责将kernel中的电源管事件转发给应用程序。这个命令是通过acpid这个服务来执行关闭电源的动作的,进入虚拟机:</p><pre><code># yum -y install acpid# /etc/init.d/acpid start</code></pre><p>CTRL+]退出。执行关闭命令</p><p>6.让虚拟机随宿主机开机启动</p><pre><code># virsh autostart centos-7.0</code></pre><p>7.挂起虚拟机</p><pre><code># virsh suspend centos-7.0</code></pre><p>8.恢复虚拟机</p><pre><code># virsh resume centos-7.0</code></pre><p>9.创建快照</p><pre><code># virsh snapshot-create centos-7.0</code></pre><p>10.列出快照</p><pre><code># virsh snapshot-list centos-7.0</code></pre><p>11.恢复快照</p><p>首先关闭kvm虚拟机，然后执行查看快照命令</p><pre><code># virsh snapshot-list centos-7.01527151925           2018-05-24 16:52:05 +0800 running</code></pre><p>恢复快照</p><pre><code>#virsh snapshot-revert centos-7.0 1527151925</code></pre><p>12.删除快照</p><pre><code># virsh snapshot-delete centos-7.0 1527151925</code></pre><p>13.克隆虚拟机</p><pre><code># virt-clone --oriainal centos-7.0 --name centos-7.1--file /kvmtest/centos-clone1.qcow2#默认是在/var/lib/libvirt/images目录下</code></pre><p>14.删除虚拟机</p><pre><code># virsh destroy centos-7.0# vitsh undefine centos-7.0# rm -f /kvmtest/centos-7.0.qcow2 </code></pre><h1 id="0x12-配置kvm虚拟机网络"><a href="#0x12-配置kvm虚拟机网络" class="headerlink" title="0x12 配置kvm虚拟机网络"></a>0x12 配置kvm虚拟机网络</h1><p>首先把VM给停了，然后修改网卡–”br0”</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm12.png" alt=""></p><p>然后虚拟机重启系统，这个时候KVM虚拟可以完全当做一台新的主机来配置网络，和宿主机是同样的地位</p><p>1).修改网卡配置文件</p><pre><code># vi /etc/sysconfig/network-scripts/ifcfg-eth0</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm13.png" alt=""></p><p>红色框里的都是要修改的，ip，网关，子网掩码按实际情况来,保存退出</p><pre><code>TYPE=EthernetBOOTPROTO=staticDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=eth0UUID=08e8d3b0-e683-4819-a560-49b5515a337aDEVICE=eth0ONBOOT=yesIPADDR0=ipNETMASK0=子网掩码GATEWAY0=网关</code></pre><p>2).修改DNS配置文件</p><pre><code># vi /etc/resolv.conf</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm14.png" alt=""><br>保存退出</p><p>3).重启网络</p><pre><code># /etc/init.d/network restart# 必要时可以重启虚拟机</code></pre><p>4).测试</p><pre><code># ping 宿主机ip# ping www.baidu.com</code></pre><p>通信正常，然后就可以通过安装vnc来远程Linux桌面了</p><h1 id="0x13-安装Tiger-VNC实现linux远程桌面连接"><a href="#0x13-安装Tiger-VNC实现linux远程桌面连接" class="headerlink" title="0x13 安装Tiger-VNC实现linux远程桌面连接"></a>0x13 安装Tiger-VNC实现linux远程桌面连接</h1><h5 id="Tiger-VNC分为客户端和服务端两部分，服务端就是现在装的kvm-将该KVM虚拟机的桌面共享出来，客户端用来远程连接到服务端的tigervnc"><a href="#Tiger-VNC分为客户端和服务端两部分，服务端就是现在装的kvm-将该KVM虚拟机的桌面共享出来，客户端用来远程连接到服务端的tigervnc" class="headerlink" title="Tiger-VNC分为客户端和服务端两部分，服务端就是现在装的kvm,将该KVM虚拟机的桌面共享出来，客户端用来远程连接到服务端的tigervnc"></a>Tiger-VNC分为客户端和服务端两部分，服务端就是现在装的kvm,将该KVM虚拟机的桌面共享出来，客户端用来远程连接到服务端的tigervnc</h5><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="1-安装Tiger-VNC服务端"><a href="#1-安装Tiger-VNC服务端" class="headerlink" title="1).安装Tiger-VNC服务端"></a>1).安装Tiger-VNC服务端</h3><pre><code># yum -y install tigervnc-server</code></pre><h3 id="2-配置Tiger-VNC"><a href="#2-配置Tiger-VNC" class="headerlink" title="2).配置Tiger-VNC"></a>2).配置Tiger-VNC</h3><pre><code># vncserver</code></pre><p>第一次启动会要求输入密码，使用客户端连接是需要输入此密码进行验证，可以使用vncpasswd修改密码</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm9.png" alt=""></p><h3 id="3-查看当前用户建立的所有远程桌面"><a href="#3-查看当前用户建立的所有远程桌面" class="headerlink" title="3).查看当前用户建立的所有远程桌面"></a>3).查看当前用户建立的所有远程桌面</h3><pre><code># vncserver -list</code></pre><h3 id="4-关闭vncserver服务端"><a href="#4-关闭vncserver服务端" class="headerlink" title="4).关闭vncserver服务端"></a>4).关闭vncserver服务端</h3><pre><code># vncserver -kill :$n</code></pre><h3 id="5-防火墙配置-我是直接关了防火墙"><a href="#5-防火墙配置-我是直接关了防火墙" class="headerlink" title="5).防火墙配置(我是直接关了防火墙)"></a>5).防火墙配置(我是直接关了防火墙)</h3><h4 id="firewall"><a href="#firewall" class="headerlink" title="firewall:"></a>firewall:</h4><pre><code># firewall-cmd --permanent --zone=public --add-port=5903/tcp# firewall-cmd --reload</code></pre><h4 id="iptables"><a href="#iptables" class="headerlink" title="iptables:"></a>iptables:</h4><pre><code># iptables -A INPUT -p tcp --dport 5903 -j ACCEPT# iptables -A OUTPUT -p tcp --sport 5903 -j ACCEPT# service iptables save</code></pre><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows:"></a>windows:</h3><p><a href="https://bintray.com/tigervnc/stable/tigervnc/1.8.0" target="_blank" rel="noopener">Windows的VNC Viewer下载</a></p><p>连接</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm10.png" alt=""></p><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1).安装"></a>1).安装</h4><pre><code># yum -y install tigervnc</code></pre><h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2).连接"></a>2).连接</h4><pre><code># vncviewer $server:$h</code></pre><p>$server指的提供远程桌面服务的电脑，可以是主机或者IP地址；$n指的是vncserver启动时指定的数字(桌面ID)</p><p>本次连接:</p><pre><code># vnciewer ip:1</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/kvm11.png" alt=""></p><p>输入密码即可连接</p><h2 id="Tiger-VNC关键配置"><a href="#Tiger-VNC关键配置" class="headerlink" title="Tiger-VNC关键配置"></a>Tiger-VNC关键配置</h2><h3 id="1-设置随系统启动"><a href="#1-设置随系统启动" class="headerlink" title="1).设置随系统启动"></a>1).设置随系统启动</h3><p>编辑vnc服务端的配置文件，在最后一行添加用户名</p><pre><code># vi /etc/sysconfig/vncserversVNCSERVERS=&quot;2:$username&quot;</code></pre><p>变量设置成自己的用户名，我使用admin用户来启动vnc服务，则改成</p><pre><code># VNCSERVERS=&quot;2:admin&quot;</code></pre><p>执行命令:</p><pre><code># chkconfig vncserver on</code></pre><h3 id="2-Tiger-VNC同步画面"><a href="#2-Tiger-VNC同步画面" class="headerlink" title="2).Tiger-VNC同步画面"></a>2).Tiger-VNC同步画面</h3><pre><code># vncserver -AlwayShared</code></pre><h4 id="到此CentOS7的KVM配置就结束了"><a href="#到此CentOS7的KVM配置就结束了" class="headerlink" title="到此CentOS7的KVM配置就结束了"></a>到此CentOS7的KVM配置就结束了</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KVM(Kernel Virtual Modle)能够提供像Vmware一样的全虚拟化功能,我们可以通过KVM虚拟机制作qcow2镜像，用于openstack环境中。&lt;/p&gt;
    
    </summary>
    
      <category term="虚拟化" scheme="https://peithon.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="kvm虚拟化" scheme="https://peithon.github.io/tags/kvm%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="virsh常用命令" scheme="https://peithon.github.io/tags/virsh%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
      <category term="tigervnc安装" scheme="https://peithon.github.io/tags/tigervnc%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>ftp服务器的简单搭建流程</title>
    <link href="https://peithon.github.io/2018/05/21/ftp-setup/"/>
    <id>https://peithon.github.io/2018/05/21/ftp-setup/</id>
    <published>2018-05-21T10:53:08.000Z</published>
    <updated>2018-10-13T00:01:23.394Z</updated>
    
    <content type="html"><![CDATA[<p>搭建ftp服务器时一般使用本地用户来访问ftp，虽然可以限制用户权限，但安全性还是没有使用虚拟用户登录高，下面通过建立虚拟用户来搭建FTP服务器。</p><a id="more"></a><h2 id="FTP用户登陆一般分为三种类型"><a href="#FTP用户登陆一般分为三种类型" class="headerlink" title="FTP用户登陆一般分为三种类型"></a>FTP用户登陆一般分为三种类型</h2><h3 id="匿名用户"><a href="#匿名用户" class="headerlink" title="匿名用户"></a>匿名用户</h3><p>不需要登陆即可直接使用FTP传输文件，匿名访问模式的FTP根目录为/var/ftp</p><h3 id="本地用户"><a href="#本地用户" class="headerlink" title="本地用户"></a>本地用户</h3><p>本地用户即服务器端（除root外）的普通用户</p><h3 id="虚拟用户"><a href="#虚拟用户" class="headerlink" title="虚拟用户"></a>虚拟用户</h3><p>在vsftpd服务器中，使用虚拟用户的主要好处在于，可以将登录的账号与系统登录的账号区分开来，用户名，密码都不相同，从而进一步增强了FTP服务器的安全性。另外虚拟用户都具有独立的配置选项。可以灵活的控制对ftp服务器的访问。可以控制用户读的权限，写权限，下载，上传的权限</p><h1 id="0x00-FTP的安装"><a href="#0x00-FTP的安装" class="headerlink" title="0x00 FTP的安装"></a>0x00 FTP的安装</h1><p>1).查询vsftpd是否安装</p><pre><code># rpm -qc vsftpd</code></pre><p>2).安装vsftpd</p><pre><code># yum -y install vsftpd</code></pre><p>3).安装vsftpd虚拟用户配置依赖包</p><pre><code># yum install -y psmisc net-tools systemd-devel libdb-devel perl-DBI</code></pre><p>4).启动vsftpd</p><pre><code># systemctl start vsftpd</code></pre><p>5).设置开机启动</p><pre><code># systemctl enable vsftpd</code></pre><h1 id="0x01-新建系统用户"><a href="#0x01-新建系统用户" class="headerlink" title="0x01 新建系统用户"></a>0x01 新建系统用户</h1><p>1).添加用户vsuser</p><pre><code>设置登录shell为/bin/false,使该用户不能登录# useradd vsuser -d /home/vsftp -s /bin/false</code></pre><p>2).修改目录的所有权</p><pre><code>递归将vsftp目录下的所有者修改为vsuser# chown vsuser:vsuser -R /home/vsftp</code></pre><h1 id="0x02-设置vsftpd服务器的配置文件"><a href="#0x02-设置vsftpd服务器的配置文件" class="headerlink" title="0x02 设置vsftpd服务器的配置文件"></a>0x02 设置vsftpd服务器的配置文件</h1><p>1).备份文件</p><pre><code># cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak</code></pre><p>2).编辑配置内容</p><pre><code># vi cp /etc/vsftpd/vsftpd.conf    #禁止匿名访问　　anonymous_enable=NO　　anon_upload_enable=NO　　anon_mkdir_write_enable=YES    chown_uploads=NO     //不允许用户修改上传文件的属主    async_abor_enable=YES               //允许执行特殊的ftp命令    ascii_upload_enable=YES              //允许使用ascii码方式上传文件    ascii_download_enable=YES            //允许使用ascii码方式下载文件    ftpd_banner=Welcome to FTP service.</code></pre><p>输入以下命令添加一些属性到配置文件：</p><pre><code># echo -e &quot;use_localtime=YES\nlisten_port=21\nchroot_local_user=YES\nidle_session_timeout=300\ndata_connection_timeout=1\nguest_enable=YES\nguest_username=vsuser #此处要和刚刚创建的用户名一致\nuser_config_dir=/etc/vsftpd/vconf\nvirtual_use_local_privs=YES\npasv_min_port=10060\npasv_max_port=10090\naccept_timeout=5\nconnect_timeout=1&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf</code></pre><p>下面是一些属性的解释：</p><pre><code>chroot_list_enable=NO 　　　　　　　　　　// 不允许用户离开自己的主目录　　chroot_list_file=/etc/vsftpd.chroot_list　　  // 虚拟用户列表，每行一个用户名　　local_enable=YES 　　　　　　　　　　 　　 // 允许本地用户访问　　write_enable=YES 　　　　　　　　　　　　 // 允许本地用户写入　　local_umask=022 　　　　　　　　　　　　 // 上传后的文件的默认掩码　　chroot_local_user=YES 　　　　　　　　　　 // 禁止本地用户离开自己的主目录　　pam_service_name=vsftpd.vu 　　　　　　 // 权限验证需要的加密文件　　guest_enable=YES 　　　　　　　　　　　　 // 开启虚拟用户功能　　guest_username=vsuser　　　　　　　　　　　// 虚拟用户的宿主目录，即虚拟用户映射为本地vsuser用户　　virtual_use_local_privs=YES 　　　　　　   // 用户登录后操作目录和本地用户权限一样　　user_config_dir=/etc/vsftpd/vconf 　　　　// 虚拟用户主目录设置文件　　allow_writeable_chroot=YES 　　　　　　 // 允许写入用户主目录，这条特别重要</code></pre><h1 id="0x03-虚拟用户个人vsftp服务器的配置文件"><a href="#0x03-虚拟用户个人vsftp服务器的配置文件" class="headerlink" title="0x03 虚拟用户个人vsftp服务器的配置文件"></a>0x03 虚拟用户个人vsftp服务器的配置文件</h1><p>1).创建文件夹</p><pre><code># mkdir /etc/vsftpd/vconf</code></pre><p>2).创建虚拟用户配置文件</p><pre><code># touch /etc/vsftpd/vconf/vsuser1# mkdir -p /home/vsftp/vsuser1/http/mydic</code></pre><h1 id="0x04-虚拟用户名单文件"><a href="#0x04-虚拟用户名单文件" class="headerlink" title="0x04 虚拟用户名单文件"></a>0x04 虚拟用户名单文件</h1><pre><code># touch /etc/vsftpd/virtusers</code></pre><p>编辑虚拟用户名单内容(奇数行是账号，偶数行是密码)：</p><pre><code>#vi /etc/vsftpd/virtusersvsuser1123456#保存退出</code></pre><h1 id="0x05-设置权限"><a href="#0x05-设置权限" class="headerlink" title="0x05 设置权限"></a>0x05 设置权限</h1><p>1).主目录不能有写的权限所以ftp为755，主目录下面的子目录设置为777权限</p><pre><code># chmod -R 755 /home/vsftp/vsuser1/http# chmod -R 777 /home/vsftp/vsuser1/http/mydic</code></pre><p>2).编辑虚拟用户配置文件</p><pre><code>#文件名要与虚拟用户名相同# vi /etc/vsftpd/vconf/vsuser1local_root=/home/vsftp/vsuser1/http/　　#设置FTP账号根目录     write_enable=YES     anon_world_readable_only=NO     anon_upload_enable=YES     anon_mkdir_write_enable=YES     anon_other_write_enable=YES         #允许删除和重名名#保存退出</code></pre><h1 id="0x06-生成虚拟用户数据文件"><a href="#0x06-生成虚拟用户数据文件" class="headerlink" title="0x06 生成虚拟用户数据文件"></a>0x06 生成虚拟用户数据文件</h1><pre><code># db_load -T -t hash -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db</code></pre><h1 id="0x07-设定PAM验证文件，并指定对虚拟用户数据库文件进行读取"><a href="#0x07-设定PAM验证文件，并指定对虚拟用户数据库文件进行读取" class="headerlink" title="0x07 设定PAM验证文件，并指定对虚拟用户数据库文件进行读取"></a>0x07 设定PAM验证文件，并指定对虚拟用户数据库文件进行读取</h1><pre><code># chmod 600 /etc/vsftpd/virtusers.db</code></pre><p>在/etc/pam.d/vsftpd文件的头部添加一下信息(只能在头部添加)</p><p>1).备份文件</p><pre><code># cp /etc/pam.d/vsftpd /etc/pam.d/vsftpd.bak</code></pre><p>2).添加信息</p><pre><code># vi /etc/pam.d/vsftpd</code></pre><p>将所有配置都注释掉，加入下面内容</p><pre><code>auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusersaccount sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers</code></pre><h1 id="0x08-防火墙配置文件"><a href="#0x08-防火墙配置文件" class="headerlink" title="0x08 防火墙配置文件"></a>0x08 防火墙配置文件</h1><p>1).关闭firewall</p><p>停止firewall</p><pre><code># systemctl stop firewalld.service</code></pre><p>禁止firewall开机启动</p><pre><code># systemctl disable firewalld.service</code></pre><p>安装iptables</p><pre><code># yum -y install iptables# yum -y update iptables</code></pre><p>2).添加防火墙规则</p><pre><code># vi /etc/sysconfig/iptables-A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 10060:10090 -j ACCEPT#保存退出</code></pre><p>3).重启防火墙</p><pre><code># systemctl restart iptables.service</code></pre><p>4).设置开机启动</p><pre><code># systemctl enable iptables.service</code></pre><h1 id="0x09-关闭SELINUX"><a href="#0x09-关闭SELINUX" class="headerlink" title="0x09 关闭SELINUX"></a>0x09 关闭SELINUX</h1><pre><code># vi /etc/selinux/config #SELINUX=enforcing #注释掉#SELINUXTYPE=targeted #注释掉SELINUX=disabled #增加#保存退出</code></pre><p>执行命令使配置生效</p><pre><code># setenforce 0</code></pre><h1 id="0X10-重启vsftpd服务器"><a href="#0X10-重启vsftpd服务器" class="headerlink" title="0X10 重启vsftpd服务器"></a>0X10 重启vsftpd服务器</h1><pre><code># systemctl restart vsftpd.service</code></pre><h1 id="0x11-安装ftp客户端"><a href="#0x11-安装ftp客户端" class="headerlink" title="0x11 安装ftp客户端"></a>0x11 安装ftp客户端</h1><pre><code># rpm -Uvh http://mirror.centos.org/centos/6/os/x86_64/Packages/ftp-0.17-54.el6.x86_64.rpm</code></pre><h1 id="0x12-FTP数字代码的意义"><a href="#0x12-FTP数字代码的意义" class="headerlink" title="0x12 FTP数字代码的意义"></a>0x12 FTP数字代码的意义</h1><pre><code>110 重新启动标记应答120 服务在多久时间内 ready 125 数据链路端口开启，准备传送 150 文件状态正常，开启数据连接端口200 命令执行成功 202 命令执行失败211 系统状态或是系统求助响应 212 目录的状态 213 文件的状态214 求助的讯息 215 名称系统类型 220 新的联机服务 ready 221 服务的控制连接端口关闭，可以注销 225 数据连结开启，但无传输动作226 关闭数据连接端口，请求的文件操作成功 227 进入 passive mode 230 使用者登入250 请求的文件操作完成257 显示目前的路径名称331 用户名称正确，需要密码332 登入时需要账号信息350 请求的操作需要进一部的命令421 无法提供服务，关闭控制连结 425 无法开启数据链路426 关闭联机，终止传输450 请求的操作未执行 451 命令终止 : 有本地的错误 452 未执行命令 : 磁盘空间不足 500 格式错误，无法识别命令 501 参数语法错误502 命令执行失败503 命令顺序错误 504 命令所接的参数不正确 530 未登入532 储存文件需要账户登入550 未执行请求的操作551 请求的命令终止，类型未知552 请求的文件终止，储存位溢出553 未执行请求的的命令，名称不正确</code></pre><h1 id="0x13-测试ftp"><a href="#0x13-测试ftp" class="headerlink" title="0x13 测试ftp"></a>0x13 测试ftp</h1><h2 id="本地测试报500错误"><a href="#本地测试报500错误" class="headerlink" title="本地测试报500错误"></a>本地测试报500错误</h2><pre><code>500 OOPS: vsftpd:  refusing to run with writable root inside chroot()</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code># vi /etc/vsftpd/vsftpd.conf</code></pre><p>添加</p><pre><code>allow_writeable_chroot=YES</code></pre><p>前面说了这一条特别重要，但是没有添加，所以才出了这样的错</p><p>重启vsftpd服务</p><pre><code>systemctl restart vsftpd.service</code></pre><p>再次登录,成功</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/ftp-5001.png" alt=""></p><p>出现数字代码229,这是被动模式的问题，登录后输入passive回车，然后再ls</p><h2 id="其他主机无法连接ftp"><a href="#其他主机无法连接ftp" class="headerlink" title="其他主机无法连接ftp"></a>其他主机无法连接ftp</h2><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>关闭防火墙# systemctl stop iptables.service</code></pre><h1 id="0x14-ftp常用命令"><a href="#0x14-ftp常用命令" class="headerlink" title="0x14 ftp常用命令"></a>0x14 ftp常用命令</h1><pre><code>ls                                    显示服务器上的目录ls [remote-dir][local-file]          显示远程目录remote-dir，并存入本地文件local-file get remote-file [local-file]           从服务器下载指定文件到客户端mget remote-files                   下载多个远程文件(mget命令允许用通配符下载多个文件)put local-file [remote-file]          从客户端上传指定文件到服务器 mput local-file                      将多个文件上传至远程主机(mput命令允许用通配符上传多个文件) open                                   连接FTP服务器 mput local-file                        将多个文件上传至远程主机(mput命令允许用通配符上传多个文件) mdelete [remote-file]                  删除远程主机文件close                                中断与远程服务器的ftp会话（与open对应）mkdir dir-name                         在远程主机中创建目录 open host[port]                        建立指定的ftp服务器连接，可指定连接端口cd directory                          改变服务器的工作目录 rename [from][to]                      更改远程主机的文件名bye|quit|exit                        退出FTP命令状态reget remote-file [local-file]         类似于get,但若local-file存在，则从上次传输中断处续传   delete remote-file                     删除远程主机文件user user-name [password][account]  向远程主机表明自己的身份，需要密码时，必须输入密码 </code></pre><h1 id="0x15-添加只有下载权限的新虚拟用户"><a href="#0x15-添加只有下载权限的新虚拟用户" class="headerlink" title="0x15 添加只有下载权限的新虚拟用户"></a>0x15 添加只有下载权限的新虚拟用户</h1><h3 id="1-创建虚拟用户的配置文件"><a href="#1-创建虚拟用户的配置文件" class="headerlink" title="1.创建虚拟用户的配置文件"></a>1.创建虚拟用户的配置文件</h3><pre><code>#文件名要与虚拟用户名相同# touch /etc/vsftpd/vconf/vsuser2# mkdir -p /home/vsftp/vsuser2/http/mydic</code></pre><h3 id="2-修改权限"><a href="#2-修改权限" class="headerlink" title="2.修改权限"></a>2.修改权限</h3><pre><code># chmod -R 755 /home/vsftp/vsuser2/http# chmod -R 777 /home/vsftp/vsuser2/http/mydic</code></pre><h3 id="3-添加虚拟用户名单内容-奇数行是账号，偶数行是密码"><a href="#3-添加虚拟用户名单内容-奇数行是账号，偶数行是密码" class="headerlink" title="3.添加虚拟用户名单内容(奇数行是账号，偶数行是密码)"></a>3.添加虚拟用户名单内容(奇数行是账号，偶数行是密码)</h3><pre><code># vi /etc/vsftpd/virtusersvsuser2123456  #保存退出</code></pre><h3 id="4-编辑虚拟用户配置文件"><a href="#4-编辑虚拟用户配置文件" class="headerlink" title="4.编辑虚拟用户配置文件"></a>4.编辑虚拟用户配置文件</h3><pre><code># vi /etc/vsftpd/vconf/vsuser2local_root=/home/vsftp/vsuser2/http/　　#设置FTP账号根目录</code></pre><h3 id="5-生成虚拟用户数据文件"><a href="#5-生成虚拟用户数据文件" class="headerlink" title="5.生成虚拟用户数据文件"></a>5.生成虚拟用户数据文件</h3><pre><code># db_load -T -t hash -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db# chmod 600 /etc/vsftpd/virtusers.db</code></pre><h3 id="6-重启服务器"><a href="#6-重启服务器" class="headerlink" title="6.重启服务器"></a>6.重启服务器</h3><pre><code># systemctl restart vsftpd.service</code></pre><h1 id="0x16-总结"><a href="#0x16-总结" class="headerlink" title="0x16 总结"></a>0x16 总结</h1><p>应该专门创建一个根目录来作为FTP的文件目录，/home目录作为敏感目录，不应该在这个目录下建立和FTP有关的文件。在进入FTP后，传输文件可能会丢一些东西，因为是传的文本，所以先输入bin命令回车，这时候传的文件就会以二进制的方式传输，就不会找出文件数据丢失的情况了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搭建ftp服务器时一般使用本地用户来访问ftp，虽然可以限制用户权限，但安全性还是没有使用虚拟用户登录高，下面通过建立虚拟用户来搭建FTP服务器。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
      <category term="FTP服务器" scheme="https://peithon.github.io/categories/Linux/FTP%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="ftp的搭建" scheme="https://peithon.github.io/tags/ftp%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    
      <category term="建立虚拟用户" scheme="https://peithon.github.io/tags/%E5%BB%BA%E7%AB%8B%E8%99%9A%E6%8B%9F%E7%94%A8%E6%88%B7/"/>
    
      <category term="ftp常用命令" scheme="https://peithon.github.io/tags/ftp%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7网络配置问题</title>
    <link href="https://peithon.github.io/2018/05/20/deploy-net/"/>
    <id>https://peithon.github.io/2018/05/20/deploy-net/</id>
    <published>2018-05-20T04:28:12.000Z</published>
    <updated>2018-10-13T00:00:40.168Z</updated>
    
    <content type="html"><![CDATA[<p>在虚拟机中安装完CentOS7之后，本来网络配置是不麻烦的，可是偏偏出现了问题，所以把这次虐心的过程记录下来。<br><a id="more"></a></p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>虚拟机: VMware Workstation 14</p><p>镜像: CentOS-7-x86_64-DVD-1611.iso</p><p>网络适配器: 桥接模式(自动)</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="1-使用NetworkManager配置"><a href="#1-使用NetworkManager配置" class="headerlink" title="1.使用NetworkManager配置"></a>1.使用NetworkManager配置</h3><pre><code># nmtui</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/1.png" alt=""></p><p>以上根据自己实际情况配置，点击确定，然后返回到终端</p><p>没有该工具使用下面语句安装:</p><pre><code># yum -y install NetworkManager-tui</code></pre><h3 id="2-修改ifcfg-ens33配置文件"><a href="#2-修改ifcfg-ens33配置文件" class="headerlink" title="2.修改ifcfg-ens33配置文件"></a>2.修改ifcfg-ens33配置文件</h3><pre><code># cd /etc/sysconfig/network-scripts/</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/2.png" alt=""></p><pre><code># vi ifcfg-ens33</code></pre><p>配置如下：</p><pre><code>YPE=EthernetBOOTPROTO=static  # 静态IPDEFROUTE=yesIPV4_FAILURE_FATAL=yesIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=c0d6a6b8-de69-45ff-86ae-1b4865250a27DEVICE=ens33ONBOOT=yes     # 系统启动激活DNS1=114.114.114.114IPADDR=10.203.87.148NETMASK=255.255.255.0PREFIX=32GATEWAY=10.203.87.254IPV6_PEERDNS=yesIPV6_PEERROUTES=yes</code></pre><p>主要改BOOTPROTO=static和ONBOOT=yes</p><h3 id="3-修改DNS配置"><a href="#3-修改DNS配置" class="headerlink" title="3.修改DNS配置"></a>3.修改DNS配置</h3><pre><code># vi /etc/resolv.conf</code></pre><p>内容：</p><pre><code>nameserver 114.114.114.114nameserver 8.8.8.8</code></pre><h3 id="4-重启网络服务"><a href="#4-重启网络服务" class="headerlink" title="4.重启网络服务"></a>4.重启网络服务</h3><pre><code># /etc/init.d/network restart</code></pre><p>或者</p><pre><code># systemctl restart network.service</code></pre><p>然后ping不通外部网络</p><h2 id="问题及解决办法"><a href="#问题及解决办法" class="headerlink" title="问题及解决办法"></a>问题及解决办法</h2><h3 id="发现的现象"><a href="#发现的现象" class="headerlink" title="发现的现象"></a>发现的现象</h3><p>1).使用命令ifconfig ifcfg-ens33查看</p><pre><code>ifcfg-ens33：error fetching interface information: Device not found</code></pre><p>2).ifcfg-ens33配置内容</p><p>重启网络后,BOOTPROTO=static 变成了 BOOTPROTO=none</p><p>3).ping网关 不通</p><p>4).ip addr</p><pre><code>ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000    link/ether 00:0c:29:ff:bd:0c brd ff:ff:ff:ff:ff:ff    inet 10.203.87.148/32 brd 10.203.87.148 scope global ens33       valid_lft forever preferred_lft forever    inet6 fe80::d8c2:956:a6a8:4b57/64 scope link        valid_lft forever preferred_lft forever</code></pre><h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><h4 id="1-执行命令cat-proc-net-dev查看网口状况，发现是存在ens33的"><a href="#1-执行命令cat-proc-net-dev查看网口状况，发现是存在ens33的" class="headerlink" title="1.执行命令cat /proc/net/dev查看网口状况，发现是存在ens33的"></a>1.执行命令cat /proc/net/dev查看网口状况，发现是存在ens33的</h4><p><img src="http://p8urkh0xe.bkt.clouddn.com/3.png" alt=""></p><h4 id="2-查看arp缓冲区"><a href="#2-查看arp缓冲区" class="headerlink" title="2.查看arp缓冲区"></a>2.查看arp缓冲区</h4><p>执行命令arp -nv查看arp缓冲区条目</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/4.png" alt=""></p><pre><code>Address：主机的IP地址Hwtype：主机的硬件类型Hwaddress：主机的硬件地址</code></pre><p>发现没有mac地址,arp表记录了ip地址与真实主机mac地址的对应关系，于是本机给网关发送的网络数据包实际上并没有发给真实的网关，这就是ping不通的原因了</p><h4 id="3-删除arp-条目"><a href="#3-删除arp-条目" class="headerlink" title="3.删除arp 条目"></a>3.删除arp 条目</h4><p>将10.03.87.254的ARP缓存删除</p><pre><code># arp -d 10.203.87.254</code></pre><h4 id="4-添加arp-条目"><a href="#4-添加arp-条目" class="headerlink" title="4.添加arp 条目"></a>4.添加arp 条目</h4><p>在能上网的主机上找到网关的mac地址，添加一个arp条目</p><pre><code># arp -s 10.203.87.254 00:1a:a9:15:4e:bd# apr -f     //刷新</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/5.png" alt=""></p><pre><code>flags mask 的值是C代表这个绑定是保存在缓冲里的flags mask 的值是CM表示静态网关,可以防止ARP欺骗    打开或建立/etc/ethers，添加内容：        10.203.87.254 00:1a:a9:15:4e:bd    这样就可以实现静态网关了</code></pre><p>如果不和局域网通信，可以把arp解析关掉</p><pre><code># ifconfig ens33 -arp</code></pre><p>然后发现当我ping一次网关,网关的mac地址就又没了,看来这也不是问题所在，最后在VMware上解决了问题</p><h4 id="5-解决方法"><a href="#5-解决方法" class="headerlink" title="5.解决方法"></a>5.解决方法</h4><p>1).在VMare上打开编辑-&gt;虚拟网络编辑器-&gt;更改设置，将桥接模式的”桥接到：自动”改成指定网卡</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/deploy_net6.png" alt=""></p><p>应用，确定</p><p>2).回到CentOS7里，编辑”/etc/sysconfig/network-scripts/ifcfg-ens33”,将BOOTPROTO的”none”改成”static”</p><p><img src="http://p8urkh0xe.bkt.clouddn.com/7.png" alt=""></p><p>3).重启网络</p><pre><code># systemctl restart network.service</code></pre><p><img src="http://p8urkh0xe.bkt.clouddn.com/deploy_net8.png" alt=""></p><p>到此解决了网络不通的问题</p><h4 id="6-配置ssh"><a href="#6-配置ssh" class="headerlink" title="6.配置ssh"></a>6.配置ssh</h4><p>1).安装ssh</p><pre><code># yum -y install ssh</code></pre><p>2).启动ssh服务</p><pre><code># systemctl start sshd# systemctl enable sshd</code></pre><p>3).使用Xshell连接，连接成功</p><h4 id="到此结束了此次虐心的网络配置"><a href="#到此结束了此次虐心的网络配置" class="headerlink" title="到此结束了此次虐心的网络配置"></a>到此结束了此次虐心的网络配置</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在虚拟机中安装完CentOS7之后，本来网络配置是不麻烦的，可是偏偏出现了问题，所以把这次虐心的过程记录下来。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://peithon.github.io/categories/Linux/"/>
    
      <category term="CentOS7" scheme="https://peithon.github.io/categories/Linux/CentOS7/"/>
    
    
      <category term="Centos7网络配置" scheme="https://peithon.github.io/tags/Centos7%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
    
      <category term="ssh服务" scheme="https://peithon.github.io/tags/ssh%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7+Hexo+Github博客简单搭建</title>
    <link href="https://peithon.github.io/2018/05/16/blog-setup/"/>
    <id>https://peithon.github.io/2018/05/16/blog-setup/</id>
    <published>2018-05-16T13:35:30.000Z</published>
    <updated>2018-10-13T18:00:56.339Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo是一款基于Node.js的快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）编写文章，可以方便的生成静态网页托管在GitHub上。</p><p>下面是我自己的博客搭建的基本流程，不包含主题美化<br><a id="more"></a></p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h2 id="1-安装Nodejs"><a href="#1-安装Nodejs" class="headerlink" title="1.安装Nodejs"></a>1.安装Nodejs</h2><p>1).下载</p><pre><code># wget https://nodejs.org/dist/v9.3.0/node-v9.3.0-linux-x64.tar.xz</code></pre><p>2).解压</p><pre><code># xz -d node-v9.3.0-linux-x64.tar.xz# tar -xvf node-v9.3.0-linux-x64.tar</code></pre><p>3).移动</p><pre><code>mv  node-v9.3.0-linux-x64 node-v9.3.0mv  node-v9.3.0 /usr/local/node</code></pre><p>4).配置环境变量</p><pre><code># vi /etc/profile# 在底部添加 PATH 变量export PATH=$PATH:/usr/local/node/bin</code></pre><p>保存退出</p><p>5).使配置生效</p><pre><code># source /etc/profile</code></pre><p>6).查看版本信息</p><pre><code># node -v v9.3.0</code></pre><h2 id="2-安装git-已安装可以跳过"><a href="#2-安装git-已安装可以跳过" class="headerlink" title="2.安装git(已安装可以跳过)"></a>2.安装git(已安装可以跳过)</h2><pre><code># yum -y install git# git --versiongit version 1.8.3.1</code></pre><h2 id="3-安装npm-已安装可以跳过"><a href="#3-安装npm-已安装可以跳过" class="headerlink" title="3.安装npm(已安装可以跳过)"></a>3.安装npm(已安装可以跳过)</h2><pre><code># yum -y install npm# npm -v3.10.10</code></pre><p>安装hexo的环境已经搭建完成，下一步就可以使用npm安装Hexo。</p><h2 id="4-安装Hexo"><a href="#4-安装Hexo" class="headerlink" title="4.安装Hexo"></a>4.安装Hexo</h2><pre><code># npm install -g hexo-cli</code></pre><h2 id="5-初始化Hexo文件夹"><a href="#5-初始化Hexo文件夹" class="headerlink" title="5.初始化Hexo文件夹"></a>5.初始化Hexo文件夹</h2><pre><code>1).首先创建一个博客目录2).进入博客目录中去3).输入以下命令：    # hexo init  //初始化博客    # npm install    # hexo -v //此时博客已经创建成功    #ls //查看都有什么文件    _config.yml  db.json  node_modules  package.json  scaffolds  source  themes</code></pre><h2 id="6-先看看效果怎么样"><a href="#6-先看看效果怎么样" class="headerlink" title="6.先看看效果怎么样"></a>6.先看看效果怎么样</h2><pre><code># hexo server //启动本地服务器，外部网络无法访问//重开一个终端,使用文本浏览器elinks访问网址//elinks安装命令 yum -y install elinks# elinks http://localhost:4000/   </code></pre><h2 id="7-创建一个github账号，并且新建一个仓库-格式如下"><a href="#7-创建一个github账号，并且新建一个仓库-格式如下" class="headerlink" title="7.创建一个github账号，并且新建一个仓库,格式如下:"></a>7.创建一个github账号，并且新建一个仓库,格式如下:</h2><pre><code>用户名.github.io   </code></pre><p>下面就开始把Hexo与Github关联起来</p><h2 id="8-修改站点配置文件-config-yml"><a href="#8-修改站点配置文件-config-yml" class="headerlink" title="8.修改站点配置文件_config.yml"></a>8.修改站点配置文件_config.yml</h2><pre><code>//翻到最后修改deploy:     type: git    repo: https://github.com/Peithon/Peithon.github.io.git    branch: master    message: &apos;站点更新:{{now("YYYY-MM-DD HH:mm:ss")}}&apos;</code></pre><p>保存站点配置文件</p><p>其实就是给<code>hexo d</code>这个命令(部署网站命令，d是deploy的缩写)做相应的配置，让Hexo知道blog要部署在GitHub的仓库里</p><h2 id="9-安装git部署插件"><a href="#9-安装git部署插件" class="headerlink" title="9.安装git部署插件"></a>9.安装git部署插件</h2><pre><code># npm install hexo-deployer-git --save</code></pre><h2 id="10-生成SSH密钥"><a href="#10-生成SSH密钥" class="headerlink" title="10.生成SSH密钥"></a>10.生成SSH密钥</h2><pre><code># cd ~/. ssh #检查本机已存在的ssh密钥# ssh-keygen -t rsa -C &quot;注册github账号的邮箱地址&quot;</code></pre><p>然后连续3次回车，最终会生成两个文件在<code>/root/.ssh</code>下，打开目录，找到<code>.ssh/id_rsa.pub</code>文件，使用<code>cat id_ras.pub</code>查看密钥内容，并将内容复制，打开你的github主页，进入个人设置-&gt;SSH and GPG keys-&gt;New SSH key,将刚复制的内容粘贴到key那里，title随便填，保存</p><h2 id="11-进行git全局配置"><a href="#11-进行git全局配置" class="headerlink" title="11.进行git全局配置"></a>11.进行git全局配置</h2><pre><code># git config --global user.name &quot;github用户名&quot;# git config --global user.email &quot;注册github的邮箱&quot;</code></pre><h2 id="12-部署博客到github上"><a href="#12-部署博客到github上" class="headerlink" title="12.部署博客到github上"></a>12.部署博客到github上</h2><pre><code># hexo clean //清除缓存，若是网页正常情况下可以忽略这条命令# hexo g   // == hexo generate  生成# hexo d   //== hexo deploy 部署</code></pre><h2 id="13-寻找图床"><a href="#13-寻找图床" class="headerlink" title="13.寻找图床"></a>13.寻找图床</h2><pre><code>把博文里的图片上传到某一网站，然后获得外部链接，这种网站被成为图床当博客中有图片时，若是很少的话可以存放在source文件中，但是显然不合理，图片会占据大量的存储的空间我们就需要找一个地方存放这些图片，然后通过外部链接取得这些图片，图床重要的是稳定速度快，所以我个人选了七牛云</code></pre><h2 id="14-更换主题"><a href="#14-更换主题" class="headerlink" title="14.更换主题"></a>14.更换主题</h2><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">主题下载</a></p><pre><code>#我使用的是smackdown主题1).从官网下载自己喜欢的主题，然后解压之后放在博客目录的themes里2).在博客目录的_config.yml文件中可以对网站信息进行修改,将theme: landscape修改成theme: smackdown(自己主题文件名),注意冒号后面有空格3).smackdown里的_config.yml文件是主题的配置文件，可以对主题进行修改4).将blog部署到github     # hexo clean     # hexo g     # hexo d</code></pre><h2 id="15-发布文章"><a href="#15-发布文章" class="headerlink" title="15.发布文章"></a>15.发布文章</h2><pre><code># hexo n &quot;文章名字&quot; </code></pre><p>在blog根目录下的source文件夹中的_post文件夹中多了一个<code>文章名字.md</code>文件</p><p>然后将写好的md文件内容复制到刚生成的md文件中,回到博客目录，部署博客</p><pre><code># hexo clean# hexo d -g</code></pre><p>现在就可以开始个人博客之旅了</p><p>至此博客基本就搭建完毕</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo是一款基于Node.js的快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）编写文章，可以方便的生成静态网页托管在GitHub上。&lt;/p&gt;
&lt;p&gt;下面是我自己的博客搭建的基本流程，不包含主题美化&lt;br&gt;
    
    </summary>
    
      <category term="博客" scheme="https://peithon.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Hexo" scheme="https://peithon.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>

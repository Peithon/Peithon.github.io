<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apache虚拟主机配置-基于端口]]></title>
    <url>%2F2018%2F08%2F11%2Fhttpd-vhosts%2F</url>
    <content type="text"><![CDATA[0x00 前言配置Apache虚拟主机，主要是监听端口，编写虚拟主机配置文件，开放端口，还有就是将web站点的目录建好。 0x01 监听端口8001修改Apache的配置文件，监听8001端口，这是用于对外进行站点访问的端口。 vi /etc/httpd/conf/httpd.conf 0x02 编写虚拟主机配置文件vi /etc/httpd/conf.d/vhosts.conf 添加以下内容： &lt;VirtualHost *:端口号&gt; #ServerName www.***.com #域名 DocumentRoot /var/www/html/web #网站目录,自己定 ErrorLog &quot;/var/log/httpd/web/error_log&quot; CustomLog &quot;/var/log/httpd/web/access_log&quot; combined &lt;Directory &quot;/var/www/html/web&quot;&gt; Options -Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 这是我在服务器上的配置: 0x03 添加目录mkdir -pv /var/log/httpd/test mkdir -pv /var/www/test 0x04 修改/etc/httpd/conf.d/welcome.conf文件这个文件是apache的测试文件，所以我们这里将该文件内容全部注释掉 为什么httpd.conf配置文件可以加载welcome.conf和vhosts.conf文件呢？ 原因很简单,因为httpd.conf的最后有这样一行代码 这一行代码会使Apache配置文件将/etc/httpd/conf.d目录下的.conf文件给包含，所以可以读取到我们新建的vhosts.conf文件。 0x04 重启apache服务(执行其中一个即可)systemctl restart httpd /etc/init.d/httpd restart 0x05 开放端口，注意把SELinux关闭#永久生效加上 --permanent firewall-cmd --zone=public --add-port=8001/tcp --permanent 0x06 测试编写一个index.html进行测试 echo &quot;hello,this is test page&quot; &gt; /var/www/test/index.html 使用curl访问页面 同时我们可以在test的访问成功的日志access_log中看到相关信息 如果想在不同的端口配置不同目录下的站点，可以在httpd.conf中添加相应端口，在vhosts.conf文件中添加相应站点信息，然后再防火墙中将端口开放，这样就可以实现同IP多端口的多个Web站点 *未经本人允许，禁止转载]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>多端口</tag>
        <tag>vhosts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker搭建Web测试环境一般步骤及相关命令总结]]></title>
    <url>%2F2018%2F07%2F22%2Fdocker-bridge-test%2F</url>
    <content type="text"><![CDATA[0x00 前言最近学习Docker中web环境的搭建，所以记录一下搭建过程中需要用到的命令以及相关步骤，本次搭建的数据库是从别的主机导出来的，所以还会涉及到一点SQL文件的导入和导出相关操作。 0x01 pull lamp镜像查找Docker Hub上的lamp镜像 [root@Peithon ~]# docker search lamp NAME DESCRIPTION STARS OFFICIAL AUTOMATED linode/lamp LAMP on Ubuntu 14.04.1 LTS Container 144 tutum/lamp Out-of-the-box LAMP image (PHP+MySQL) 97 greyltc/lamp a super secure, up-to-date and lightweight L… 85 [OK] fauria/lamp Modern, developer friendly LAMP stack. Inclu… 41 [OK] janes/alpine-lamp lamp base on alpine linux 35 [OK] nickistre/ubuntu-lamp LAMP server on Ubuntu 26 [OK] mattrayner/lamp A simple LAMP docker image running the prere… 22 [OK] nickistre/centos-lamp LAMP on centos setup 21 [OK] nickistre/ubuntu-lamp-wordpress LAMP on Ubuntu with wp-cli installed 9 [OK] lioshi/lamp Docker image for LAMP + MySql under debian 9 [OK] x4j5/silverstripe-lamp lamp stack for silverstripe development (Deb… 5 [OK] nickistre/ubuntu-lamp-xdebug LAMP on Ubuntu with xdebug installed 4 [OK] sminnee/silverstripe-lamp Docker image for SilverStripe LAMP stack tha… 4 nickistre/centos-lamp-wordpress LAMP on CentOS setups with wp-cli installed 3 [OK] dell/lamp-base Base LAMP Image for dependant images 3 nickistre/centos-lamp-xdebug LAMP on centos with xDebug 3 [OK] shelleyma/lampp2 lampp from github 2 [OK] gizra/drupal-lamp A base LAMP docker file for drupal projects. 2 [OK] theodotos/ubuntu-lamp A LAMP (Linux/Apache/MariaDB/PHP) image base… 2 lead4good/lamp-php LAMP Stack PHP 1 [OK] ready2order/lamp LAMP 1 thinkiq/lamp ThinkIQ Lamp image 0 [OK] davefx/trusty-lamp-selenium-headless Ubuntu 14.04 system with configured LAMP ser… 0 [OK] greyltc/lamp-aur LAMP stack (in Arch with php7) with AUR acce… 0 [OK] lead4good/lamp-mysql LAMP-Stack MySQL 0 [OK] 拉取镜像到本地 [root@Peithon ~]# docker pull tutum/lamp 0x02 网络模式的选择使用docker run创建Docker容器时，需要根据自己的需要选择容器的网络模式，在Docker中有四种网络模式可以供我们选择,通常使用birdge模式比较多见。 1). bridge模式：使用–net=bridge指定，默认设置当我们的Docker server启动时，会在主机创建一个docker0的虚拟网桥，当我们选择使用bridge模式，会为每一个容器分配Network Namespace、设置IP等，每个bridge模式的容器之间可以相互通信，主机和容器之间可以相互通信，但是外部无法访问到这些容器，而docker0就类似于交换机一样的功能。 # [root@Peithon ~]# docker run -d --name=webtest --net=bridge 3d49e175ec00 可以看到会从172.17.0.0/16这个网段随机分配一个没有被使用的ip，因为网络模式默认是使用bridge模式的，所以可以不用使用命令来指定。 使用docker network inspect bridge可以查看该网络模式下有哪些容器 2). host模式：使用–net=host指定启动容器时使用host模式，容器将不会拥有自己独立的Network Namespace和IP,而是和主机共享同一个Network Namespace，容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 [root@Peithon ~]# docker run -d --name=webtest3 --net=host 3d49e175ec00 下面是主机的 查看网络模式为host的信息 通过这种方式创建的容器，容器发生端口冲突 3). none模式：使用–net=none指定(也可以使用–network none)该模式有自己独立的Network Namespace，但不为Docker容器进行任何网络配置，需要自己手动添加。 [root@Peithon ~]# docker run -d --name webtest4 --network none 3d49e175ec00 这种模式下的容器外部无法访问，可以放一些重要的文件或者工具，这样只有本地可以访问，安全性会比较高。 4). container模式：使用–net=container:NAMEorID指定指定新创建的容器和已经存在的一个容器共用一个Network Namespace，而不是和宿主机共享，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。 [root@Peithon ~]# docker run -d --name webtest5 --network container:webtest 3d49e175ec00 可以看出webtest5和webtest是共享网络的。 本次搭建将使用bridge模式,并将上面测试所建容器删除 0x03 创建容器，并将80端口转发到宿主机的8001端口[root@Peithon ~]# docker run -d --name test1 -p 8001:80 tutum/lamp 通过将容器的端口转发到宿主机，在宿主机上可以访问本机的端口来访问Docker容器中的服务 在防火墙开放8001端口，使外部网络也能对其进行访问 [root@Peithon ~]# firewall-cmd --zone=public --add-port=8001/tcp --permanent [root@Peithon ~]# firewall-cmd --reload #重启firewall 0x04 主机和容器之间文件的拷贝1).将本地的/opt/src/Web1下的html文件拷贝到test1容器中的/var/www目录下docker cp 宿主机中要拷贝的文件名及其路径 容器名：要拷贝到容器里面对应的路径 在宿主机执行命令 [root@Peithon ~]# docker cp /opt/src/Web1/html test1:/var/www 2).将test1容器中的/var/www目录下的html文件拷贝到本地的/opt/src/Web1下在宿主机执行命令 [root@Peithon ~]# docker cp test1:/var/www/html /opt/src/Web1 拷贝命令不管容器有没有启动都生效 通过docker cp将宿主机上的站点文件拷贝到Docker容器中 0x05 从宿主机的数据库中导出SQL文件，导入到Docker中的数据库中mysqldump -h localhost -u root -p 数据库名 &gt;/opt/src/Web1/dbsqlfile.sql [root@Peithon ~]# mysqldump -h localhost -u root -p ctf1003 &gt;/opt/src/Web1/dbctf1003.sql 输入密码，到此将mysql数据库中的ctf1003数据库导出到dbctf1003.sql文件中了 Docker中的数据库默认没有密码的，所以还需要我们设置一下密码 #登录数据库之后 &gt;set password for &apos;root&apos;@&apos;localhost&apos;=password(&apos;123456&apos;); &gt;create database ctf1003; 将SQL文件导入数据到Docker容器中的数据库中 [root@Peithon ~]# mysql -h localhost -u root -p ctf1003 &lt; /opt/src/Web1/dbctf1003.sql 输入密码，然后就OK了 0x06 提交容器打包成新的镜像[root@Peithon ~]# docker commit -a &quot;Peithon&quot; -m &quot;Web 测试&quot; e61c66465773 ubuntu:web500 e61c66465773 ：CONTAINER IDubuntu:web500 -&gt;新镜像的REPOSITORY:TAG 查看刚打包的镜像 0x07 上传到Docker Hub上1). 标记镜像docker tag image username/repository:tag [root@Peithon ~]# docker tag ubuntu:web500 peithon/ubuntu:web500 2).Docker Hub账号登录[root@Peithon ~]# docker login 然后输入用户密码，登录成功之后将镜像标记然后上传。 3).将标记镜像上传到存储库docker push username/repository:tag [root@Peithon ~]# docker push peithon/ubuntu:web500 登录到Docker Hub上查看是否上传成功 至此就基本完成了环境的搭建 *未经本人允许，禁止转载]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>sql文件导出和导入</tag>
        <tag>容器端口转发</tag>
        <tag>Docker网络模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux内核引发的Docker安装失败问题]]></title>
    <url>%2F2018%2F06%2F03%2Flinux-kernel%2F</url>
    <content type="text"><![CDATA[自己租了一个阿里云服务器，在上面搭建了docker环境，学习docker也有一段时间了，今天想在自己的CentOS7虚拟机中在安装一个docker，问题就随着出现了。这个问题花费了一些时间，不过最后总算解决了。 软件环境: 操作系统: CentOS7 内核版本：3.10.0-514 其他：VMware14 出现的问题： Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 我的yum源都是换过的，没有使用CentOS7自带的yum源。替换成阿里云源了 Docker守护进程JSON配置文件: /etc/docker/daemon.json Docker守护进程数据保存目录: /var/lib/docker Docker守护进程日志: /var/log/messages Docker守护进程默认监听的Unix域套接字：/var/run/docker.sock 0x01 安装docker[admin@localhost ~]$ sudo yum install -y docker [admin@localhost ~]$ docker -v Docker version 1.13.1, build 94f4240/1.13.1 [admin@localhost ~]$ sudo docker info Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 这个时候就出现了问题，百度Google了很多，都没有找到合适的解决办法。 0x02 查看docker daemon有没有运行[admin@localhost ~]$ ps aux | grep docker admin 4319 0.0 0.0 112664 972 pts/0 R+ 18:57 0:00 grep --color=auto docker 可以判断docker daemon是没有运行的 0x03 手动启动守护程序[admin@localhost log]$ dockerd INFO[0000] libcontainerd: new containerd process, pid: 4521 WARN[0000] containerd: low RLIMIT_NOFILE changing to max current=1024 max=4096 INFO[0001] [graphdriver] using prior storage driver: overlay2 INFO[0001] Graph migration to content-addressability took 0.00 seconds INFO[0001] Loading containers: start. INFO[0001] Firewalld running: true INFO[0001] Default bridge (docker0) is assigned with an IP address 172.17.0.0/16. Daemon option --bip can be used to set a preferred IP address INFO[0001] Loading containers: done. WARN[0001] Not using native diff for overlay2, this may cause degraded performance for building images: opaque flag erroneously copied up, consider update to kernel 4.8 or later to fix WARN[0001] failed to retrieve docker-runc version: exec: &quot;docker-runc&quot;: executable file not found in $PATH WARN[0001] failed to retrieve docker-init version INFO[0001] Daemon has completed initialization INFO[0001] Docker daemon commit=&quot;94f4240/1.13.1&quot; graphdriver=overlay2 version=1.13.1 INFO[0001] API listen on /var/run/docker.sock 这些是之前的记录，然后再开一个终端，再次查看一遍信息，在新开的终端输入:sudo docker info 新终端: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 1.13.1 Storage Driver: overlay2 Backing Filesystem: xfs Supports d_type: true Native Overlay Diff: false Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1) runc version: N/A (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f) init version: N/A (expected: 949e6facb77383876aeff8a6944dde66b3089574) Security Options: seccomp Profile: default Kernel Version: 3.10.0-514.el7.x86_64 Operating System: CentOS Linux 7 (Core) OSType: linux Architecture: x86_64 Number of Docker Hooks: 3 CPUs: 1 Total Memory: 976.5 MiB Name: localhost.localdomain ID: QA5O:XAFA:Y6MT:P7HC:HR6A:YFQ5:QITP:EDNR:6IMA:THF7:UKBE:CUD5 Docker Root Dir: /var/lib/docker Debug Mode (client): false Debug Mode (server): false Registry: https://index.docker.io/v1/ Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false Registries: docker.io (secure) 守护进程所在终端: INFO[0000] libcontainerd: new containerd process, pid: 4521 WARN[0000] containerd: low RLIMIT_NOFILE changing to max current=1024 max=4096 INFO[0001] [graphdriver] using prior storage driver: overlay2 INFO[0001] Graph migration to content-addressability took 0.00 seconds INFO[0001] Loading containers: start. INFO[0001] Firewalld running: true INFO[0001] Default bridge (docker0) is assigned with an IP address 172.17.0.0/16. Daemon option --bip can be used to set a preferred IP address INFO[0001] Loading containers: done. WARN[0001] Not using native diff for overlay2, this may cause degraded performance for building images: opaque flag erroneously copied up, consider update to kernel 4.8 or later to fix WARN[0001] failed to retrieve docker-runc version: exec: &quot;docker-runc&quot;: executable file not found in $PATH WARN[0001] failed to retrieve docker-init version INFO[0001] Daemon has completed initialization INFO[0001] Docker daemon commit=&quot;94f4240/1.13.1&quot; graphdriver=overlay2 version=1.13.1 INFO[0001] API listen on /var/run/docker.sock WARN[0050] failed to retrieve docker-runc version: exec: &quot;docker-runc&quot;: executable file not found in $PATH WARN[0050] failed to retrieve docker-init version 0x04 查看日志[admin@localhost ~]$ sudo cat /var/log/messages May 31 19:21:09 localhost dbus[660]: [system] Activating via systemd: service name=&apos;net.reactivated.Fprint&apos; unit=&apos;fprintd.service&apos; May 31 19:21:09 localhost dbus-daemon: dbus[660]: [system] Activating via systemd: service name=&apos;net.reactivated.Fprint&apos; unit=&apos;fprintd.service&apos; May 31 19:21:09 localhost systemd: Starting Fingerprint Authentication Daemon... May 31 19:21:09 localhost dbus[660]: [system] Successfully activated service &apos;net.reactivated.Fprint&apos; May 31 19:21:09 localhost dbus-daemon: dbus[660]: [system] Successfully activated service &apos;net.reactivated.Fprint&apos; May 31 19:21:09 localhost systemd: Started Fingerprint Authentication Daemon. May 31 19:21:09 localhost fprintd: Launching FprintObject May 31 19:21:09 localhost fprintd: ** Message: D-Bus service launched with name: net.reactivated.Fprint May 31 19:21:09 localhost fprintd: ** Message: entering main loop May 31 19:21:39 localhost fprintd: ** Message: No devices in use, exit 没有看出什么问题 0x05 启动docker$ systemctl start docker //没有启动成功 $ journalctl -xe -- Unit docker.service has begun starting up. 6月 03 11:18:42 localhost.localdomain dockerd-current[50448]: time=&quot;2018-06-03T11:18:42.746059974+08:00&quot; level=info msg=&quot;libcontainerd: new containerd process, pid: 50453&quot; 6月 03 11:18:44 localhost.localdomain dockerd-current[50448]: Error starting daemon: SELinux is not supported with the overlay2 graph driver on this kernel. Either boot into a new 6月 03 11:18:44 localhost.localdomain systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE 6月 03 11:18:44 localhost.localdomain systemd[1]: Failed to start Docker Application Container Engine. -- Subject: Unit docker.service has failed -- Defined-By: systemd -- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel -- -- Unit docker.service has failed. -- -- The result is failed. 6月 03 11:18:44 localhost.localdomain systemd[1]: Unit docker.service entered failed state. 6月 03 11:18:44 localhost.localdomain systemd[1]: docker.service failed. 6月 03 11:18:44 localhost.localdomain polkitd[648]: Unregistered Authentication Agent for unix-process:50367:23334872 (system bus name :1.1153, object path /org/freedesktop/Policy 6月 03 11:19:07 localhost.localdomain fprintd[50383]: ** Message: No devices in use, exit SELinux不支持这个内核上的overlay2图形驱动程序，终于找到了问题所在，原来是内核不支持，我用的是3.10.0-514的内核，所以将内核升级就可以了 0x06 升级内核—解决方法1).导入ELRepo软件仓库的公共秘钥 $ sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org 2).安装ELRepo软件仓库的yum源 $ sudo rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm 3).安装主线内核（ml=mainline） $ sudo yum --enablerepo=elrepo-kernel install kernel-ml 4).重启系统 $ reboot 5).选择进入4.16.13-1.e17内核的系统 6).查看内核以及docker信息 $ uname -r $ systemctl start docker $ docker info 现在docker就可以正常使用了 0x07 出现该问题的因素1.docker没有启动$ systemctl start docker 2.该系统的内核不支持升级内核 3.用户没有管理docker的权限$ sudo docker info 或者创建一个docker用户组，将该普通用户加入到docker组中，这样用户就可以管理docker了。 $ sudo groupadd docker $ sudo usermod -aG docker admin 目前所了解就这三个因素，如果有其他因素以后碰到会再来补充。 0x08 总结但是没有及时查看Docker的状态，这也是花费这么长时间的原因之一，还有就是对Docker的守护进程以及套接字之间理解的不是很好，所以出现问题才会没有清晰的排查思路，通过这次问题的解决，的确让我对Docker套接字还有守护进程之类的加深了理解。所以我相信，只要能够不断解决问题，在学习上就能学的更多，理解的更透彻。 *未经本人允许，禁止转载]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh安全加固]]></title>
    <url>%2F2018%2F05%2F31%2Fssh-safety%2F</url>
    <content type="text"><![CDATA[每一台服务器基本都会配置ssh服务，但是如果我们不对ssh进行安全防护，就相当于给入侵者提供了一个入侵途径。所以对ssh进行一些安全配置十分重要。 0x00 前言ssh服务的配置文件:/etc/ssh/sshd_config ssh日志文件:/var/log/secure 0x01 更换ssh服务的端口ssh服务默认是22端口，修改的时候如果系统的SELinux是开启的话是不会成功的，会报以下的端口错误。 因为SELinux开启时ssh不能在另一个端口运行 1).检查允许监听哪些端口sshd $ semanage port -l | grep ssh ssh_port_t tcp 22 2).关闭SELinux或者添加一条规则 a.关闭SELinux $ sudo vi /etc/selinux/config #SELINUX=enforcing #注释掉 #SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 #保存退出 执行命令使配置生效 $ sudo setenforce 0 b.添加规则 $ sudo semanage port -a -t ssh_port_t -p tcp 30102 若semanage命令不可以，使用命令yum install -y policycoreutils-python安装policycoreutils-python包 3).修改端口号(17行) $ sudo vi /etc/ssh/sshd_config 17 Port 30102 4).重启ssh服务 $ systemctl restart sshd 5).测试30102是否可用 $ ssh -p 30102 localhost 6).在防火墙把22端口关闭 $ sudo firewall-cmd --remove-port=22/tcp --permanent –permanent表示永久生效，重启不会丢失配置 7).重新加载配置 $ sudo firewall-cmd --reload 8).查看22端口的开放情况 $ sudo firewall-cmd --query-port=22/tcp no 9).防火墙开放30102端口 $ sudo firewall-cmd --add-port=30102/tcp --permanent $ sudo firewall-cmd --reload $ systemctl restart sshd 10).其他主机即可通过30102端口远程此电脑 #查看开放的所有端口 $ sudo firewall-cmd --zone=public --list-ports 0x02 改变ssh版本目前存在两种SSH（版本1和版本2）。Red Hat Enterprise Linux下的OpenSSH套件使用SSH版本2，该版本具有增强的密钥交换算法，不易受到版本1中的攻击。修改配置文件第23行。 23 Protocol 2 0x03 禁止root登录使用其他用户登录，这样既较低了用户权限，同时其他用户的账号攻击者还得猜解，这大大增加了攻击难度。修改配置文件49行 49 PermitRootLogin no 0x04 通过密钥登录不允许密码登录，利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。可以有效防止SSH暴力破解。如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。或者采用双因子认证。 #修改配置文件77行,先允许密码登录，后面的步骤需要远程下载私钥文件 $ sudo vi /etc/ssh/sshd_config 77 PasswordAuthentication yes #允许密钥登录,54、55行 54 RSAAuthentication yes 55 PubkeyAuthentication yes #保存退出 1).制作密钥对密码登录到打算使用密钥登录的账户,建立密钥对 $ ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/home/admin/.ssh/id_rsa): 回车 Enter passphrase (empty for no passphrase): 输入密钥锁码，或直接按 Enter 留空 Enter same passphrase again: 确认密钥锁码 Your identification has been saved in /home/admin/.ssh/id_rsa. &lt;== 私钥 Your public key has been saved in /home/admin/.ssh/id_rsa.pub. &lt;== 公钥 The key fingerprint is: b7:af:ce:02:0d:d0:8d:64:80:11:13:1f:ed:c9:4f:5e admin@localhost.localdomain The key&apos;s randomart image is: +--[ RSA 2048]----+ | ==o=oo | | .o.o+ . | | .+ . | | = . E | | *S.. | | . +. . | | . . | | .. . | | o+.. | +-----------------+ 密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。 在admin用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥 2).在服务器配置公钥$ cd .ssh $ cat id_rsa.pub &gt;&gt; authorized_keys $ chmod 600 authorized_keys $ chmod 700 ~/.ssh $systemctl restart sshd 3).下载密钥(id_rsa)文件到本地4).修改配置文件,不允许密码登录$ sudo vi /etc/ssh/sshd_config 77 PasswordAuthentication yes #保存退出 $ systemctl restart sshd 5).使用Xshell远程连接 浏览-&gt;文件-&gt;选择id_rsa-&gt;输入密钥锁码-&gt;确认即可连接 0x05 设置黑白名单通过设置黑白名单可以限制访问,这样可以大大提高安全性 限制用户1).设置登录用户白名单在/etc/ssh/sshd_config配置文件中设置AllowUsers选项 # 允许testadmin和从192.168.0.1 登录的test帐户通过SSH登录系统。 AllowUsers testadmin test@192.168.0.1 2).设置登录用户黑名单在/etc/ssh/sshd_config配置文件中设置DenyUsers选项 #不允许testadmin用户登录系统 DenyUsers testadmin 限制IP1).设置IP白名单在/etc/hosts.allow中添加IP $ sudo vi /etc/hosts.allow # # hosts.allow This file contains access rules which are used to # allow or deny connections to network services that # either use the tcp_wrappers library or that have been # started through a tcp_wrappers-enabled xinetd. # # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; # for information on rule syntax. # See &apos;man tcpd&apos; for information on tcp_wrappers sshd:192.168.0.1:allow sshd:192.168.0.1/24:allow 在上面文件中添加了两个内容 sshd:192.168.0.1:allow #允许IP192.168.0.1登录ssh sshd:192.168.0.1/24:allow #允许192.168.0.1/24这段IP的用户登录ssh 2).设置IP黑名单$ sudo vi /etc/hosts.deny # # hosts.deny This file contains access rules which are used to # deny connections to network services that either use # the tcp_wrappers library or that have been # started through a tcp_wrappers-enabled xinetd. # # The rules in this file can also be set up in # /etc/hosts.allow with a &apos;deny&apos; option instead. # # See &apos;man 5 hosts_options&apos; and &apos;man 5 hosts_access&apos; # for information on rule syntax. # See &apos;man tcpd&apos; for information on tcp_wrappers sshd:ALL #拒绝全部的ssh登录 3).hosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高0x06 设置多长时间没有成功连接上就断线默认的等待时间为 2 分钟，如果没有单位将以秒作为单位，可用的单位分别为 h，m、s，时间越短越安全。 $ sudo vi /etc/ssh/sshd_config 48 LoginGraceTime 30s #保存退出 $systemctl restart sshd 0x07 配置Fail2ban、denyhosts等当因为某些需要不得不使用密码登录时，使用Fail2ban可以缓解ssh服务器的暴力破解,通过配置Fail2ban来自动屏蔽针对SSH,HTTP等各服务的暴力密码猜解或者DDOS攻击等,降低暴力破解对服务器造成的威胁。 *未经本人允许，禁止转载]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>密钥登录</tag>
        <tag>ssh安全加固</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用源代码搭建LNMP动态网站]]></title>
    <url>%2F2018%2F05%2F28%2Flnmp-setup%2F</url>
    <content type="text"><![CDATA[想搭建一个练习平台，之前一直使用的是LAMP环境搭建的,使用的是yum仓库。这次想尝试使用LNMP来搭建，利用源代码安装，熟悉一下Nginx。 0x00 更换yum源为阿里云源1).备份原来的源 # mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 2).下载新的源到/etc/yum.repos.d/目录下 # wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 3)生成缓存 # yum makecache 0x01 安装编译程序源码的环境# yum install -y apr* autoconf automake bison bzip2 bzip2* compat* cpp curl curl-devel fontconfig fontconfig-devel freetype freetype* freetype-devel gcc gcc-c++ gd gettext gettext-devel glibc kernel kernel-headers keyutils keyutils-libs-devel krb5-devel libcom_err-devel libpng libpng-devel libjpeg* libsepol-devel libselinux-devel libstdc++-devel libtool* libgomp libxml2 libxml2-devel libXpm* libtiff libtiff* make mpfr ncurses* ntp openssl openssl-devel patch pcre-devel perl php-common php-gd policycoreutils telnet t1lib t1lib* nasm nasm* wget zlib-devel 0x02 下载搭建LNMP所需的软件包# cd /usr/local/src 通过百度云链接下载，将软件包放到该目录下 0x03 安装CMake1).解压tar包 # tar xzvf cmake-2.8.11.2.tar.gz 2).进入cmake-2.8.11.2目录,并执行安装 # cd cmake-2.8.11.2/ # ./configure 3).编译源代码生成可执行文件 # make 4).安装编译成功的可执行文件，一般目录在/usr/local/bin下 # make install CMake是Linux系统下常用的编译工具，因为使用源码包安装编译时需要用到，所以先安装，通常源码安装四个步骤 1).下载及解压源码包文件 2).编译源码包代码 3).生成二进制安装程序 4).运行二进制的服务程序安装包 0x04 安装MYSQL数据库在系统中创建一个名为sqladmin的用户，专门用于负责运行MySQL数据库。并把该账户的Bash终端设置成nologin解释器，提高系统的安全性。 回到/usr/local/src目录下 1).添加本地用户sqladmin,设置shell为nologin # useradd mysql -s /sbin/nologin 2).创建目录用于保存MySQL数据库有关文件 # mkdir -p /usr/local/mysql/var 3).将该目录的所有者和所属组身份修改为sqladmin # chown -Rf mysql:mysql /usr/local/mysql 4).解压MySQL源代码tar包 # tar xzvf mysql-5.6.19.tar.gz 5).编译数据库 # cd mysql-5.6.19/ # cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/usr/local/mysql/var -DSYSCONFDIR=/etc 各参数意义: -DCMAKE_INSTALL_PREFIX 用于定义数据库服务程序的保存目录 -DMYSQL_DATADIR 用于定义真实数据库文件的目录 -DSYSCONFDIR 定义MySQL数据库配置文件的保存目录 6).编译源代码生成二可执行文件 # make 7).安装可执行程序 # make install 8).删除/etc目录中的mysql的默认配置文件 # rm -rf /etc/my.cnf 9).进入数据库服务程序的保存目录 在scripts内找到一个名为mysql_install_db的脚本程序，并执行这个脚本程序 # cd /usr/local/mysql # ./scripts/mysql_install_db --user=sqladmin --basedir=/usr/local/mysql --datadir=/usr/local/mysql/var 10).新生成的MySQL数据库配置文件链接到/etc目录中 # ln -s my.cnf /etc/my.cnf 11).程序目录中的开机程序文件复制到/etc/rc.d/init.d目录中 # cp ./support-files/mysql.server /etc/rc.d/init.d/mysqld 12).修改数据库脚本权限 # chmod 755 /etc/rc.d/init.d/mysqld 13).修改MySQL数据库的脚本文件 # vi /etc/rc.d/init.d/mysqld 命令模式输入”:set nu”显示所有行数,填入信息 46 basedir=/usr/local/mysql 47 datadir=/usr/local/mysql/var #保存退出 14).启动数据库 # service mysqld start 启动数据库出现问题： Starting MySQL. ERROR! The server quit without updating PID file (/usr/local/mysql/var/localhost.localdomain.pid). 解决过程： 刚开始我以为是没有localhost.localdomain.pid,所以我建了这个文件，然后发现当我想启动mysql时，新建的.pid文件就消失了 卧榻，网上Google了半天各种办法都试过了也没解决，回头看到一个localhost.localdomain.err文件，打开看到一行关键信息 119563 [ERROR] Fatal error: Can&apos;t change to run as user &apos;mysql&apos; ; Please check that the user exists! 原来是没有mysql这个用户，赶紧把之前建的sqladmin用户删除了，新建了mysql用户，并重修修改了mysql文件的所有者和权限 并且把前面的步骤内容更改了一下，但是问题记录了下来，localhost.localdomain.err文件路径:/usr/local/mysql/var/localhost.localdomain.err 解决问题的步骤： # userdel sqladmin(之前新建的sqlamdin用户) # useradd mysql -s /sbin/nologin # chown -Rf mysql:mysql /usr/local/mysql # service mysqld start #然后数据库启动成功,可以进行下一步安装 15.将MySQL服务设置开机启动 # chkconfig mysqld on 16.编辑/etc/profile文件将命令所保存的目录永久性地定义到PATH变量 mysql数据库自带了许多命令，但是Bash终端的PATH变量并不包含这些命令所在的目录，所以需要自己添加，这样当物理设备在下一次重启时就会永久生效了。使用source命令加载一下/ect/profile文件，此时新的PATH变量也可以立即生效了。 # vi /etc/profile 使用”:set nu”命令查看所有行数，在47行添加 export PATH=$PATH:/usr/local/mysql/bin # source /etc/profile 17.初始化MySQL数据库 # mysql_secure_installation 设置参数如下 NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MySQL SERVERS IN PRODUCTION USE! PLEASE READ EACH STEP CAREFULLY! In order to log into MySQL to secure it, we&apos;ll need the current password for the root user. If you&apos;ve just installed MySQL, and you haven&apos;t set the root password yet, the password will be blank, so you should just press enter here. Enter current password for root (enter for none): 回车 OK, successfully used password, moving on... Setting the root password ensures that nobody can log into the MySQL root user without the proper authorisation. Set root password? [Y/n] y（为数据库管理员root设置密码） New password: 输入密码 Re-enter new password: 确认密码 Password updated successfully! Reloading privilege tables.. ... Success! By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? [Y/n] y （删除匿名用户） ... Success! Normally, root should only be allowed to connect from &apos;localhost&apos;. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? [Y/n] y （禁止root远程登录） ... Success! By default, MySQL comes with a database named &apos;test&apos; that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? [Y/n] y （删除test数据库并取消对其的访问权限） - Dropping test database... ... Success! - Removing privileges on test database... ... Success! Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? [Y/n] y （刷新授权，让初始化立即生效） ... Success! All done! If you&apos;ve completed all of the above steps, your MySQL installation should now be secure. Thanks for using MySQL! Cleaning up... 0x05 配置Nginx服务安装Nginx所需的依赖包1.安装pcre包软件包pcre是Nginx服务程序用于实现伪静态功能必不可少的依赖包 1).进入/usr/local/src目录，解压tar包 # tar xzvf pcre-8.35.tar.gz 2).进入pcre目录，编译 # cd pcre-8.35 # ./configure --prefix=/usr/local/pcre 3).生成可执行文件 # make 4).执行 # make install 2.安装openssl包openssl软件包是用于提供网站加密证书服务的程序文件，在安装该程序时需要自定义服务程序的安装目录，以便于稍后调用它们的时候更可控。 # cd /usr/local/src # tar xzvf pcre-8.35.tar.gz # cd pcre-8.35 # ./configure --prefix=/usr/local/pcre # make # make install 配置openssl的配置文件，将命令目录添加到PATH环境变量中去,使用source命令让它立即生效 # vi /etc/profile # source /etc/profile 3.安装zlib包zlib软件包是用于提供压缩功能的函数库文件 # cd /usr/local/src # tar xzvf zlib-1.2.8.tar.gz # cd zlib-1.2.8 # ./configure --prefix=/usr/local/zlib # make # make install 创建执行Nginx服务程序的账号# cd /usr/local/src # useradd www -s /sbin/nologin 安装Nginx服务器# tar xzvf nginx-1.6.0.tar.gz # cd nginx-1.6.0/ # ./configure --prefix=/usr/local/nginx --without-http_memcached_module --user=www --group=www --with-http_stub_status_module --with-http_ssl_module --with-http_gzip_static_module --with-openssl=/usr/local/src/openssl-1.0.1h --with-zlib=/usr/local/src/zlib-1.2.8 --with-pcre=/usr/local/src/pcre-8.35 # make # make install 参数意义： –prefix参数用于定义服务程序稍后安装到的位置 –user与–group参数用于指定执行Nginx服务程序的用户名和用户组 在使用参数调用openssl、zlib、pcre软件包时，写出软件源码包的解压路径，而不是程序的安装路径 将Nginx设置到开机启动项中# vi /etc/rc.d/init.d/nginx 配置脚本文件(因为没有nginx这个文件，直接copy就好) #!/bin/bash # nginx - this script starts and stops the nginx daemon # chkconfig: - 85 15 # description: Nginx is an HTTP(S) server, HTTP(S) reverse \ # proxy and IMAP/POP3 proxy server # processname: nginx # config: /etc/nginx/nginx.conf # config: /usr/local/nginx/conf/nginx.conf # pidfile: /usr/local/nginx/logs/nginx.pid # Source function library. . /etc/rc.d/init.d/functions # Source networking configuration. . /etc/sysconfig/network # Check that networking is up. [ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0 nginx=&quot;/usr/local/nginx/sbin/nginx&quot; prog=$(basename $nginx) NGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot; [ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginx lockfile=/var/lock/subsys/nginx make_dirs() { # make required directories user=`$nginx -V 2&gt;&amp;1 | grep &quot;configure arguments:&quot; | sed &apos;s/[^*]*--user=\([^ ]*\).*/\1/g&apos; -` if [ -z &quot;`grep $user /etc/passwd`&quot; ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep &apos;configure arguments:&apos;` for opt in $options; do if [ `echo $opt | grep &apos;.*-temp-path&apos;` ]; then value=`echo $opt | cut -d &quot;=&quot; -f 2` if [ ! -d &quot;$value&quot; ]; then # echo &quot;creating&quot; $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done } start() { [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $&quot;Starting $prog: &quot; daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval } stop() { echo -n $&quot;Stopping $prog: &quot; killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval } restart() { #configtest || return $? stop sleep 1 start } reload() { #configtest || return $? echo -n $&quot;Reloading $prog: &quot; killproc $nginx -HUP RETVAL=$? echo } force_reload() { restart } configtest() { $nginx -t -c $NGINX_CONF_FILE } rh_status() { status $prog } rh_status_q() { rh_status &gt;/dev/null 2&gt;&amp;1 } case &quot;$1&quot; in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $&quot;Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}&quot; exit 2 esac #保存退出 为脚本赋予755权限，然后使用chkconfig命令添加服务到开机启动项# chmod 755 /etc/rc.d/init.d/nginx # /etc/rc.d/init.d/nginx restart //以绝对路径执行该脚本 状态： Reloading systemd: [ 确定 ] Restarting nginx (via systemctl): [ 确定 ] 在nginx-1.6.0目录下 root@localhost nginx-1.6.0]# chkconfig nginx on 查看是否安装成功# elinks 服务器ip 0x06 配置PHP服务php具有开源、免费、快捷、跨平台性强、效率高等优良特性，是目前Web开发领域最常用的语言之一,安装php比安装Nginx还要复杂，得先安装很多依赖包，所以用源码包安装LNMP环境特别耗费时间 安装依赖包1.安装yasm包yasm源码包是一款常见的开源汇编器 # cd /usr/local/src # tar zxvf yasm-1.2.0.tar.gz # cd yasm-1.2.0 # ./configure # make # make install 2.安装libmcrypt包libmcrypt源码包是用于加密算法的扩展库程序 # cd /usr/local/src # tar zxvf libmcrypt-2.5.8.tar.gz # cd libmcrypt-2.5.8 # ./configure # make # make install 3.安装libvpx包libvpx源码包是用于提供视频编码器的服务程序 # cd /usr/local/src # tar xjvf libvpx-v1.3.0.tar.bz2 # cd libvpx-v1.3.0 # ./configure --prefix=/usr/local/libvpx --enable-shared --enable-vp9 # make # make install 4.安装tiff包tiff源码包是用于提供标签图像文件格式的服务程序 # tar zxvf tiff-4.0.3.tar.gz # cd tiff-4.0.3 # ./configure --prefix=/usr/local/tiff --enable-shared # make # make install 5.安装libpng包libpng源码包是用于提供png图片格式支持函数库的服务程序 # cd /usr/local/src # tar zxvf libpng-1.6.12.tar.gz # cd libpng-1.6.12 # ./configure --prefix=/usr/local/libpng --enable-shared # make # make install 6.安装freetype包freetype源码包是用于提供字体支持引擎的服务程序 # cd /usr/local/src # tar zxvf freetype-2.5.3.tar.gz # cd freetype-2.5.3 # ./configure --prefix=/usr/local/freetype --enable-shared # make # make install 7.安装jpeg包jpeg源码包是用于提供jpeg图片格式支持函数库的服务程序 # cd /usr/local/src # tar zxvf jpegsrc.v9a.tar.gz # cd jpeg-9a # ./configure --prefix=/usr/local/jpeg --enable-shared # mkae # make install 8.安装libgd包libgd源码包是用于提供图形处理的服务程序，编译时要写入jpeg、libpng、freetype、tiff、libvpx等服务程序在系统中的安装路径 # cd .. # tar zxvf libgd-2.1.0.tar.gz # ./configure --prefix=/usr/local/libgd --enable-shared --with-jpeg=/usr/local/jpeg --with-png=/usr/local/libpng --with-freetype=/usr/local/freetype --with-fontconfig=/usr/local/freetype --with-xpm=/usr/ --with-tiff=/usr/local/tiff --with-vpx=/usr/local/libvpx # make # make install 9.安装t1lib包t1lib源码包是用于提供图片生成函数库的服务程序 # cd .. # tar zxvf t1lib-5.1.2.tar.gz # cd t1lib-5.1.2 # ./configure --prefix=/usr/local/t1lib --enable-shared # make # make install # ln -s /usr/lib64/libltdl.so /usr/lib/libltdl.so # cp -frp /usr/lib64/libXpm.so* /usr/lib/ 安装php服务在开始编译php源码包之前，先定义一个名为LD_LIBRARY_PATH的全局环境变量，该环境变量的作用是帮助系统找到指定的动态链接库文件，这些文件是编译php服务源码包的必须元素之一。编译php服务源码包时，除了定义要安装到的目录以外，还需要依次定义配置php服务程序配置文件的保存目录、MySQL数据库服务程序所在目录、MySQL数据库服务程序配置文件所在目录，以及libpng、jpeg、freetype、libvpx、zlib、t1lib等服务程序的安装目录路径，并通过参数启动php服务程序的诸多默认功能 # cd .. # tar -zvxf php-5.5.14.tar.gz # cd php-5.5.14 # export LD_LIBRARY_PATH=/usr/local/libgd/lib # ./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysql=/usr/local/mysql --with-mysqli=/usr/local/mysql/bin/mysql_config --with-mysql-sock=/tmp/mysql.sock --with-pdo-mysql=/usr/local/mysql --with-gd --with-png-dir=/usr/local/libpng --with-jpeg-dir=/usr/local/jpeg --with-freetype-dir=/usr/local/freetype --with-xpm-dir=/usr/ --with-vpx-dir=/usr/local/libvpx/ --with-zlib-dir=/usr/local/zlib --with-t1lib=/usr/local/t1lib --with-iconv --enable-libxml --enable-xml --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-opcache --enable-mbregex --enable-fpm --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-mcrypt --with-curl --enable-ctype # make # make install 修改php配置文件# rm -rf /etc/php.ini # ln -s /usr/local/php/etc/php.ini /etc/php.ini # cp php.ini-production /usr/local/php/etc/php.ini # cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf # ln -s /usr/local/php/etc/php-fpm.conf /etc/php-fpm.conf 修改php-fpm.conf文件分别将第148和149行的user与group参数分别修改为www账户和用户组名称 # vi /usr/local/php/etc/php-fpm.conf 把php-fpm服务程序加入到开机启动项为了能够执行脚本，为脚本赋予755权限。 # cp sapi/fpm/init.d.php-fpm /etc/rc.d/init.d/php-fpm # chmod 755 /etc/rc.d/init.d/php-fpm # chkconfig php-fpm on 修改php.ini配置文件在305行的disable_functions参数后面追加上要禁止的功能 # vi /usr/local/php/etc/php.ini 0x07 修改Nginx配置文件# vi /usr/local/nginx/conf/nginx.conf 把第2行的注释删除，然后在后面写上负责运行Nginx服务程序的账户名称和用户组名称 在第45行的index参数后面写上网站的首页名称 将第65～71行参数前的注释删除来启用参数，主要是修改第69行的脚本名称路径参数，其中$document_root变量即为网站信息存储的根目录路径，若没有设置该变量，则Nginx服务程序无法找到网站信息，因此会提示“404页面未找到”的报错信息 在确认参数信息填写正确后便可重启Nginx服务与php-fpm服务 0x08 重启服务# systemctl restart nginx # systemctl restart php-fpm 到了这一步LNMP环境就搭建完成了 0x09 测试为了测试LNMP环境搭建是否妥当，部署Discuz!系统 1).解压dz # cd /usr/local/src/ # unzip Discuz_X3.2_SC_GBK.zip 2).将文件放在服务器目录 解压后会在当前目录中出现一个名为upload的文件目录，这里面保存的就是Discuz！论坛的系统程序。把Nginx服务程序网站根目录的内容清空后，就可以把这些这个目录中的文件都复制进去 # # rm -rf /usr/local/nginx/html/{index.html,50x.html}* # mv upload/* /usr/local/nginx/html/ 3).修改属主和权限 把Nginx服务程序的网站根目录的所有者和所属组修改为本地的www用户,并赋予755权限以便于能够读、写、执行该论坛系统内的文件 # chown -Rf www:www /usr/local/nginx/html # chmod -Rf 755 /usr/local/nginx/html 4).在浏览器输入http://服务器ip/install/,开始安装 5).确保当前状态都是可写，然后进行下一步 6).选择“全新安装Discuz! X（含UCenter Server）”,后面填写要求的信息 7).安装成功，说明 既然环境没有问题.接下就是搭建练习平台了。 *未经本人允许，禁止转载]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>lnmp搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7下部署KVM以及virsh常用命令]]></title>
    <url>%2F2018%2F05%2F25%2Fkvm-deploy%2F</url>
    <content type="text"><![CDATA[KVM(Kernel Virtual Modle)能够提供像Vmware一样的全虚拟化功能,我们可以通过KVM虚拟机制作qcow2镜像，用于openstack环境中。 0x00 检测CPU支不支持虚拟化# egrep -o &apos;(vmx|svm)&apos; /proc/cpuinfo 输出vmx的值说明是支持的,没有的话到Vmware开启 0x01 安装KVM以及相关依赖包# yum -y groupinstall &quot;Virtualization Host&quot; # yum -y install virt-{install,viewer,manager} 0x02 配置网络，让KVM中虚拟机能共享网络1).让系统支持ipv4的转发功能 # echo &quot;net.ipv4.ip_forward = 1&quot; &gt; /etc/sysctl.d/99-ipforward.conf 2).让转发功能立即生效 # sysctl -p /etc/sysctl.d/99-ipforward.conf 0x03 检查kvm模块是否被加载# lsmod | grep kvm 0x04 禁用并卸载NetworkManager工具(必要)，启用自带的network服务# chkconfig NetworkManager off # chkconfig network on # service NetworkManager stop # yum erase NetworkManager 0x05 设置网卡为桥接模式使用”ip link show”查看网卡的Mac地址 # cp /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts/ifcfg-ens33.bak # vi /etc/sysconfig/network-scripts/ifcfg-ens33 编辑网卡配置文件，将ip等信息注释后追加参数BRIDGE=br0 TYPE=Ethernet BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=yes IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=c0d6a6b8-de69-45ff-86ae-1b4865250a27 DEVICE=ens33 ONBOOT=yes #DNS1=114.114.114.114 #IPADDR=10.203.87.111 #PREFIX=32 #GATEWAY=10.203.87.254 IPV6_PEERDNS=yes IPV6_PEERROUTES=yes BRIDGE=&quot;br0&quot; #保存退出 0x06 创建用于桥接网卡的配置文件# vi /etc/sysconfig/network-scripts/ifcfg-br0 添加以下内容 DEVICE=&quot;br0&quot; TYPE=BRIDGE ONBOOT=yes BOOTPROTO=static IPADDR=&quot;10.203.87.111&quot; NETMASK=&quot;255.255.255.0&quot; GATEWAY=&quot;10.203.87.254&quot; DNS1=&quot;114.114.114.114&quot; #保存退出 0x07 重启网络# /etc/init.d/network restart 要是出问题就直接重启系统(reboot)或者执行以下命令 # ifdown br0 # ifdown ens33 # ifup br0 # ifup ens33 0x08 查看路由及网卡桥接# route # brctl show # ifconfig 这样就把ens33桥接为br0网卡了,KVM就可以使用这个桥接配置了 0x09 获取虚拟机列表# virsh -c qemu:///system list 或者使用”virsh list –all”查看 现在还没有安装虚拟机，所以列表是空的 0x10 配置虚拟机1).设置语言环境 # vi /etc/locale.conf 语言设为英文LANG=”en_US.UTF-8” 2).创建安装盘 # qemu-img create -f qcow2 /kvmtest/Centos-7.qcow2 8G 3).创建虚拟机 # virt-install --virt-type kvm --name centos-7.0 --ram 1024 \ --vcpus 1 \ --cdrom=/kvmtest/CentOS-7-x86_64-DVD-1611.iso \ --disk path=/kvmtest/Centos-7.qcow2,size=8,format=qcow2 \ --network bridge=br0 \ --graphics vnc,listen=0.0.0.0 --noautoconsole \ --os-type=linux --os-variant=rhel6 各个参数的意义： --name 虚拟机名称 --vcpus 虚拟机虚拟CPU个数 --ram 虚拟机内存 --disk 虚拟机使用的磁盘路径 --network 网络设置 --cdrom 设置光驱获取虚拟光驱文件的路径 --os-variant 指示为特定的操作系统版本 4).使用”virsh list –all”查看 然后执行命令”virt-manager”就会发现有虚拟机在安装，选中centos-7.0，点击Open，然后就开始进行图形界面安装吧,和安装虚拟机的步骤一样。 0x11 KVM virsh常用命令1.列出全部虚拟机 # virsh list --all 2.启动虚拟机 # virsh start centos-7.0 //列出的name列 3.进入虚拟机 # virsh console centos-7.0 4.退出虚拟机 CTRL+] 5.关闭虚拟机 # virsh shutdown centos-7.0 刚开始是不可以关闭的，因为还没有安装acpid服务，它是linux内核与应用程序之间的通信接口，负责将kernel中的电源管事件转发给应用程序。这个命令是通过acpid这个服务来执行关闭电源的动作的,进入虚拟机: # yum -y install acpid # /etc/init.d/acpid start CTRL+]退出。执行关闭命令 6.让虚拟机随宿主机开机启动 # virsh autostart centos-7.0 7.挂起虚拟机 # virsh suspend centos-7.0 8.恢复虚拟机 # virsh resume centos-7.0 9.创建快照 # virsh snapshot-create centos-7.0 10.列出快照 # virsh snapshot-list centos-7.0 11.恢复快照 首先关闭kvm虚拟机，然后执行查看快照命令 # virsh snapshot-list centos-7.0 1527151925 2018-05-24 16:52:05 +0800 running 恢复快照 #virsh snapshot-revert centos-7.0 1527151925 12.删除快照 # virsh snapshot-delete centos-7.0 1527151925 13.克隆虚拟机 # virt-clone --oriainal centos-7.0 --name centos-7.1--file /kvmtest/centos-clone1.qcow2 #默认是在/var/lib/libvirt/images目录下 14.删除虚拟机 # virsh destroy centos-7.0 # vitsh undefine centos-7.0 # rm -f /kvmtest/centos-7.0.qcow2 0x12 配置kvm虚拟机网络首先把VM给停了，然后修改网卡–”br0” 然后虚拟机重启系统，这个时候KVM虚拟可以完全当做一台新的主机来配置网络，和宿主机是同样的地位 1).修改网卡配置文件 # vi /etc/sysconfig/network-scripts/ifcfg-eth0 红色框里的都是要修改的，ip，网关，子网掩码按实际情况来,保存退出 TYPE=Ethernet BOOTPROTO=static DEFROUTE=yes PEERDNS=yes PEERROUTES=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_PEERDNS=yes IPV6_PEERROUTES=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=08e8d3b0-e683-4819-a560-49b5515a337a DEVICE=eth0 ONBOOT=yes IPADDR0=ip NETMASK0=子网掩码 GATEWAY0=网关 2).修改DNS配置文件 # vi /etc/resolv.conf 保存退出 3).重启网络 # /etc/init.d/network restart # 必要时可以重启虚拟机 4).测试 # ping 宿主机ip # ping www.baidu.com 通信正常，然后就可以通过安装vnc来远程Linux桌面了 0x13 安装Tiger-VNC实现linux远程桌面连接Tiger-VNC分为客户端和服务端两部分，服务端就是现在装的kvm,将该KVM虚拟机的桌面共享出来，客户端用来远程连接到服务端的tigervnc服务端1).安装Tiger-VNC服务端# yum -y install tigervnc-server 2).配置Tiger-VNC# vncserver 第一次启动会要求输入密码，使用客户端连接是需要输入此密码进行验证，可以使用vncpasswd修改密码 3).查看当前用户建立的所有远程桌面# vncserver -list 4).关闭vncserver服务端# vncserver -kill :$n 5).防火墙配置(我是直接关了防火墙)firewall:# firewall-cmd --permanent --zone=public --add-port=5903/tcp # firewall-cmd --reload iptables:# iptables -A INPUT -p tcp --dport 5903 -j ACCEPT # iptables -A OUTPUT -p tcp --sport 5903 -j ACCEPT # service iptables save 客户端windows:Windows的VNC Viewer下载 连接 Linux:1).安装# yum -y install tigervnc 2).连接# vncviewer $server:$h $server指的提供远程桌面服务的电脑，可以是主机或者IP地址；$n指的是vncserver启动时指定的数字(桌面ID) 本次连接: # vnciewer ip:1 输入密码即可连接 Tiger-VNC关键配置1).设置随系统启动编辑vnc服务端的配置文件，在最后一行添加用户名 # vi /etc/sysconfig/vncservers VNCSERVERS=&quot;2:$username&quot; 变量设置成自己的用户名，我使用admin用户来启动vnc服务，则改成 # VNCSERVERS=&quot;2:admin&quot; 执行命令: # chkconfig vncserver on 2).Tiger-VNC同步画面# vncserver -AlwayShared 到此CentOS7的KVM配置就结束了*未经本人允许，禁止转载]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>kvm虚拟化</tag>
        <tag>virsh常用命令</tag>
        <tag>tigervnc安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ftp服务器的简单搭建流程]]></title>
    <url>%2F2018%2F05%2F21%2Fftp-setup%2F</url>
    <content type="text"><![CDATA[搭建ftp服务器时一般使用本地用户来访问ftp，虽然可以限制用户权限，但安全性还是没有使用虚拟用户登录高，下面通过建立虚拟用户来搭建FTP服务器。 FTP用户登陆一般分为三种类型匿名用户不需要登陆即可直接使用FTP传输文件，匿名访问模式的FTP根目录为/var/ftp 本地用户本地用户即服务器端（除root外）的普通用户 虚拟用户在vsftpd服务器中，使用虚拟用户的主要好处在于，可以将登录的账号与系统登录的账号区分开来，用户名，密码都不相同，从而进一步增强了FTP服务器的安全性。另外虚拟用户都具有独立的配置选项。可以灵活的控制对ftp服务器的访问。可以控制用户读的权限，写权限，下载，上传的权限 0x00 FTP的安装1).查询vsftpd是否安装 # rpm -qc vsftpd 2).安装vsftpd # yum -y install vsftpd 3).安装vsftpd虚拟用户配置依赖包 # yum install -y psmisc net-tools systemd-devel libdb-devel perl-DBI 4).启动vsftpd # systemctl start vsftpd 5).设置开机启动 # systemctl enable vsftpd 0x01 新建系统用户1).添加用户vsuser 设置登录shell为/bin/false,使该用户不能登录 # useradd vsuser -d /home/vsftp -s /bin/false 2).修改目录的所有权 递归将vsftp目录下的所有者修改为vsuser # chown vsuser:vsuser -R /home/vsftp 0x02 设置vsftpd服务器的配置文件1).备份文件 # cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak 2).编辑配置内容 # vi cp /etc/vsftpd/vsftpd.conf #禁止匿名访问 anonymous_enable=NO anon_upload_enable=NO anon_mkdir_write_enable=YES chown_uploads=NO //不允许用户修改上传文件的属主 async_abor_enable=YES //允许执行特殊的ftp命令 ascii_upload_enable=YES //允许使用ascii码方式上传文件 ascii_download_enable=YES //允许使用ascii码方式下载文件 ftpd_banner=Welcome to FTP service. 输入以下命令添加一些属性到配置文件： # echo -e &quot;use_localtime=YES\nlisten_port=21\nchroot_local_user=YES\nidle_session_timeout=300 \ndata_connection_timeout=1\nguest_enable=YES\nguest_username=vsuser #此处要和刚刚创建的用户名一致 \nuser_config_dir=/etc/vsftpd/vconf\nvirtual_use_local_privs=YES \npasv_min_port=10060\npasv_max_port=10090 \naccept_timeout=5\nconnect_timeout=1&quot; &gt;&gt; /etc/vsftpd/vsftpd.conf 下面是一些属性的解释： chroot_list_enable=NO // 不允许用户离开自己的主目录 chroot_list_file=/etc/vsftpd.chroot_list // 虚拟用户列表，每行一个用户名 local_enable=YES // 允许本地用户访问 write_enable=YES // 允许本地用户写入 local_umask=022 // 上传后的文件的默认掩码 chroot_local_user=YES // 禁止本地用户离开自己的主目录 pam_service_name=vsftpd.vu // 权限验证需要的加密文件 guest_enable=YES // 开启虚拟用户功能 guest_username=vsuser // 虚拟用户的宿主目录，即虚拟用户映射为本地vsuser用户 virtual_use_local_privs=YES // 用户登录后操作目录和本地用户权限一样 user_config_dir=/etc/vsftpd/vconf // 虚拟用户主目录设置文件 allow_writeable_chroot=YES // 允许写入用户主目录，这条特别重要 0x03 虚拟用户个人vsftp服务器的配置文件1).创建文件夹 # mkdir /etc/vsftpd/vconf 2).创建虚拟用户配置文件 # touch /etc/vsftpd/vconf/vsuser1 # mkdir -p /home/vsftp/vsuser1/http/mydic 0x04 虚拟用户名单文件# touch /etc/vsftpd/virtusers 编辑虚拟用户名单内容(奇数行是账号，偶数行是密码)： #vi /etc/vsftpd/virtusers vsuser1 123456 #保存退出 0x05 设置权限1).主目录不能有写的权限所以ftp为755，主目录下面的子目录设置为777权限 # chmod -R 755 /home/vsftp/vsuser1/http # chmod -R 777 /home/vsftp/vsuser1/http/mydic 2).编辑虚拟用户配置文件 #文件名要与虚拟用户名相同 # vi /etc/vsftpd/vconf/vsuser1 local_root=/home/vsftp/vsuser1/http/ #设置FTP账号根目录 write_enable=YES anon_world_readable_only=NO anon_upload_enable=YES anon_mkdir_write_enable=YES anon_other_write_enable=YES #允许删除和重名名 #保存退出 0x06 生成虚拟用户数据文件# db_load -T -t hash -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db 0x07 设定PAM验证文件，并指定对虚拟用户数据库文件进行读取# chmod 600 /etc/vsftpd/virtusers.db 在/etc/pam.d/vsftpd文件的头部添加一下信息(只能在头部添加) 1).备份文件 # cp /etc/pam.d/vsftpd /etc/pam.d/vsftpd.bak 2).添加信息 # vi /etc/pam.d/vsftpd 将所有配置都注释掉，加入下面内容 auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/virtusers 0x08 防火墙配置文件1).关闭firewall 停止firewall # systemctl stop firewalld.service 禁止firewall开机启动 # systemctl disable firewalld.service 安装iptables # yum -y install iptables # yum -y update iptables 2).添加防火墙规则 # vi /etc/sysconfig/iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 10060:10090 -j ACCEPT #保存退出 3).重启防火墙 # systemctl restart iptables.service 4).设置开机启动 # systemctl enable iptables.service 0x09 关闭SELINUX# vi /etc/selinux/config #SELINUX=enforcing #注释掉 #SELINUXTYPE=targeted #注释掉 SELINUX=disabled #增加 #保存退出 执行命令使配置生效 # setenforce 0 0X10 重启vsftpd服务器# systemctl restart vsftpd.service 0x11 安装ftp客户端# rpm -Uvh http://mirror.centos.org/centos/6/os/x86_64/Packages/ftp-0.17-54.el6.x86_64.rpm 0x12 FTP数字代码的意义110 重新启动标记应答 120 服务在多久时间内 ready 125 数据链路端口开启，准备传送 150 文件状态正常，开启数据连接端口 200 命令执行成功 202 命令执行失败 211 系统状态或是系统求助响应 212 目录的状态 213 文件的状态 214 求助的讯息 215 名称系统类型 220 新的联机服务 ready 221 服务的控制连接端口关闭，可以注销 225 数据连结开启，但无传输动作 226 关闭数据连接端口，请求的文件操作成功 227 进入 passive mode 230 使用者登入 250 请求的文件操作完成 257 显示目前的路径名称 331 用户名称正确，需要密码 332 登入时需要账号信息 350 请求的操作需要进一部的命令 421 无法提供服务，关闭控制连结 425 无法开启数据链路 426 关闭联机，终止传输 450 请求的操作未执行 451 命令终止 : 有本地的错误 452 未执行命令 : 磁盘空间不足 500 格式错误，无法识别命令 501 参数语法错误 502 命令执行失败 503 命令顺序错误 504 命令所接的参数不正确 530 未登入 532 储存文件需要账户登入 550 未执行请求的操作 551 请求的命令终止，类型未知 552 请求的文件终止，储存位溢出 553 未执行请求的的命令，名称不正确 0x13 测试ftp本地测试报500错误500 OOPS: vsftpd: refusing to run with writable root inside chroot() 解决方法# vi /etc/vsftpd/vsftpd.conf 添加 allow_writeable_chroot=YES 前面说了这一条特别重要，但是没有添加，所以才出了这样的错 重启vsftpd服务 systemctl restart vsftpd.service 再次登录,成功 出现数字代码229,这是被动模式的问题，登录后输入passive回车，然后再ls 其他主机无法连接ftp解决方法关闭防火墙 # systemctl stop iptables.service 0x14 ftp常用命令ls 显示服务器上的目录 ls [remote-dir][local-file] 显示远程目录remote-dir，并存入本地文件local-file get remote-file [local-file] 从服务器下载指定文件到客户端 mget remote-files 下载多个远程文件(mget命令允许用通配符下载多个文件) put local-file [remote-file] 从客户端上传指定文件到服务器 mput local-file 将多个文件上传至远程主机(mput命令允许用通配符上传多个文件) open 连接FTP服务器 mput local-file 将多个文件上传至远程主机(mput命令允许用通配符上传多个文件) mdelete [remote-file] 删除远程主机文件 close 中断与远程服务器的ftp会话（与open对应） mkdir dir-name 在远程主机中创建目录 open host[port] 建立指定的ftp服务器连接，可指定连接端口 cd directory 改变服务器的工作目录 rename [from][to] 更改远程主机的文件名 bye|quit|exit 退出FTP命令状态 reget remote-file [local-file] 类似于get,但若local-file存在，则从上次传输中断处续传 delete remote-file 删除远程主机文件 user user-name [password][account] 向远程主机表明自己的身份，需要密码时，必须输入密码 0x15 添加只有下载权限的新虚拟用户1.创建虚拟用户的配置文件#文件名要与虚拟用户名相同 # touch /etc/vsftpd/vconf/vsuser2 # mkdir -p /home/vsftp/vsuser2/http/mydic 2.修改权限# chmod -R 755 /home/vsftp/vsuser2/http # chmod -R 777 /home/vsftp/vsuser2/http/mydic 3.添加虚拟用户名单内容(奇数行是账号，偶数行是密码)# vi /etc/vsftpd/virtusers vsuser2 123456 #保存退出 4.编辑虚拟用户配置文件# vi /etc/vsftpd/vconf/vsuser2 local_root=/home/vsftp/vsuser2/http/ #设置FTP账号根目录 5.生成虚拟用户数据文件# db_load -T -t hash -f /etc/vsftpd/virtusers /etc/vsftpd/virtusers.db # chmod 600 /etc/vsftpd/virtusers.db 6.重启服务器# systemctl restart vsftpd.service 0x16 总结应该专门创建一个根目录来作为FTP的文件目录，/home目录作为敏感目录，不应该在这个目录下建立和FTP有关的文件。在进入FTP后，传输文件可能会丢一些东西，因为是传的文本，所以先输入bin命令回车，这时候传的文件就会以二进制的方式传输，就不会找出文件数据丢失的情况了。 未经本人允许，禁止转载]]></content>
      <categories>
        <category>Linux</category>
        <category>FTP服务器</category>
      </categories>
      <tags>
        <tag>ftp的搭建</tag>
        <tag>建立虚拟用户</tag>
        <tag>ftp常用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7网络配置问题]]></title>
    <url>%2F2018%2F05%2F20%2Fdeploy-net%2F</url>
    <content type="text"><![CDATA[在虚拟机中安装完CentOS7之后，本来网络配置是不麻烦的，可是偏偏出现了问题，所以把这次虐心的过程记录下来。 环境虚拟机: VMware Workstation 14 镜像: CentOS-7-x86_64-DVD-1611.iso 网络适配器: 桥接模式(自动) 网络配置1.使用NetworkManager配置# nmtui 以上根据自己实际情况配置，点击确定，然后返回到终端 没有该工具使用下面语句安装: # yum -y install NetworkManager-tui 2.修改ifcfg-ens33配置文件# cd /etc/sysconfig/network-scripts/ # vi ifcfg-ens33 配置如下： YPE=Ethernet BOOTPROTO=static # 静态IP DEFROUTE=yes IPV4_FAILURE_FATAL=yes IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=c0d6a6b8-de69-45ff-86ae-1b4865250a27 DEVICE=ens33 ONBOOT=yes # 系统启动激活 DNS1=114.114.114.114 IPADDR=10.203.87.148 NETMASK=255.255.255.0 PREFIX=32 GATEWAY=10.203.87.254 IPV6_PEERDNS=yes IPV6_PEERROUTES=yes 主要改BOOTPROTO=static和ONBOOT=yes 3.修改DNS配置# vi /etc/resolv.conf 内容： nameserver 114.114.114.114 nameserver 8.8.8.8 4.重启网络服务# /etc/init.d/network restart 或者 # systemctl restart network.service 然后ping不通外部网络 问题及解决办法发现的现象1).使用命令ifconfig ifcfg-ens33查看 ifcfg-ens33：error fetching interface information: Device not found 2).ifcfg-ens33配置内容 重启网络后,BOOTPROTO=static 变成了 BOOTPROTO=none 3).ping网关 不通 4).ip addr ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 00:0c:29:ff:bd:0c brd ff:ff:ff:ff:ff:ff inet 10.203.87.148/32 brd 10.203.87.148 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::d8c2:956:a6a8:4b57/64 scope link valid_lft forever preferred_lft forever 解决过程1.执行命令cat /proc/net/dev查看网口状况，发现是存在ens33的 2.查看arp缓冲区执行命令arp -nv查看arp缓冲区条目 Address：主机的IP地址 Hwtype：主机的硬件类型 Hwaddress：主机的硬件地址 发现没有mac地址,arp表记录了ip地址与真实主机mac地址的对应关系，于是本机给网关发送的网络数据包实际上并没有发给真实的网关，这就是ping不通的原因了 3.删除arp 条目将10.03.87.254的ARP缓存删除 # arp -d 10.203.87.254 4.添加arp 条目在能上网的主机上找到网关的mac地址，添加一个arp条目 # arp -s 10.203.87.254 00:1a:a9:15:4e:bd # apr -f //刷新 flags mask 的值是C代表这个绑定是保存在缓冲里的 flags mask 的值是CM表示静态网关,可以防止ARP欺骗 打开或建立/etc/ethers，添加内容： 10.203.87.254 00:1a:a9:15:4e:bd 这样就可以实现静态网关了 如果不和局域网通信，可以把arp解析关掉 # ifconfig ens33 -arp 然后发现当我ping一次网关,网关的mac地址就又没了,看来这也不是问题所在，最后在VMware上解决了问题 5.解决方法1).在VMare上打开编辑-&gt;虚拟网络编辑器-&gt;更改设置，将桥接模式的”桥接到：自动”改成指定网卡 应用，确定 2).回到CentOS7里，编辑”/etc/sysconfig/network-scripts/ifcfg-ens33”,将BOOTPROTO的”none”改成”static” 3).重启网络 # systemctl restart network.service 到此解决了网络不通的问题 6.配置ssh1).安装ssh # yum -y install ssh 2).启动ssh服务 # systemctl start sshd # systemctl enable sshd 3).使用Xshell连接，连接成功 到此结束了此次虐心的网络配置*未经本人允许，禁止转载]]></content>
      <categories>
        <category>Linux</category>
        <category>CentOS7</category>
      </categories>
      <tags>
        <tag>Centos7网络配置</tag>
        <tag>ssh服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7+Hexo+Github博客简单搭建]]></title>
    <url>%2F2018%2F05%2F16%2Fblog-setup%2F</url>
    <content type="text"><![CDATA[Hexo是一款基于Node.js的快速，简单而强大的博客框架。我们可以使用Markdown（或其他语言）编写文章，可以方便的生成静态网页托管在GitHub上。 下面是我自己的博客搭建的基本流程，不包含主题美化 搭建步骤1.安装Nodejs1).下载 # wget https://nodejs.org/dist/v9.3.0/node-v9.3.0-linux-x64.tar.xz 2).解压 # xz -d node-v9.3.0-linux-x64.tar.xz # tar -xvf node-v9.3.0-linux-x64.tar 3).移动 mv node-v9.3.0-linux-x64 node-v9.3.0 mv node-v9.3.0 /usr/local/node 4).配置环境变量 # vi /etc/profile # 在底部添加 PATH 变量 export PATH=$PATH:/usr/local/node/bin 保存退出 5).使配置生效 # source /etc/profile 6).查看版本信息 # node -v v9.3.0 2.安装git(已安装可以跳过)# yum -y install git # git --version git version 1.8.3.1 3.安装npm(已安装可以跳过)# yum -y install npm # npm -v 3.10.10 安装hexo的环境已经搭建完成，下一步就可以使用npm安装Hexo。 4.安装Hexo# npm install -g hexo-cli 5.初始化Hexo文件夹1).首先创建一个博客目录 2).进入博客目录中去 3).输入以下命令： # hexo init //初始化博客 # npm install # hexo -v //此时博客已经创建成功 #ls //查看都有什么文件 _config.yml db.json node_modules package.json scaffolds source themes 6.先看看效果怎么样# hexo server //启动本地服务器，外部网络无法访问 //重开一个终端,使用文本浏览器elinks访问网址 //elinks安装命令 yum -y install elinks # elinks http://localhost:4000/ 7.创建一个github账号，并且新建一个仓库,格式如下:用户名.github.io 下面就开始把Hexo与Github关联起来 8.修改站点配置文件_config.yml//翻到最后修改 deploy: type: git repo: https://github.com/Peithon/Peithon.github.io.git branch: master message: &apos;站点更新:{{now("YYYY-MM-DD HH:mm:ss")}}&apos; 保存站点配置文件 其实就是给hexo d这个命令(部署网站命令，d是deploy的缩写)做相应的配置，让Hexo知道blog要部署在GitHub的仓库里 9.安装git部署插件# npm install hexo-deployer-git --save 10.生成SSH密钥# cd ~/. ssh #检查本机已存在的ssh密钥 # ssh-keygen -t rsa -C &quot;注册github账号的邮箱地址&quot; 然后连续3次回车，最终会生成两个文件在/root/.ssh下，打开目录，找到.ssh/id_rsa.pub文件，使用cat id_ras.pub查看密钥内容，并将内容复制，打开你的github主页，进入个人设置-&gt;SSH and GPG keys-&gt;New SSH key,将刚复制的内容粘贴到key那里，title随便填，保存 11.进行git全局配置# git config --global user.name &quot;github用户名&quot; # git config --global user.email &quot;注册github的邮箱&quot; 12.部署博客到github上# hexo clean //清除缓存，若是网页正常情况下可以忽略这条命令 # hexo g // == hexo generate 生成 # hexo d //== hexo deploy 部署 13.寻找图床把博文里的图片上传到某一网站，然后获得外部链接，这种网站被成为图床 当博客中有图片时，若是很少的话可以存放在source文件中，但是显然不合理，图片会占据大量的存储的空间 我们就需要找一个地方存放这些图片，然后通过外部链接取得这些图片，图床重要的是稳定速度快，所以我个人选了七牛云 14.更换主题主题下载 #我使用的是smackdown主题 1).从官网下载自己喜欢的主题，然后解压之后放在博客目录的themes里 2).在博客目录的_config.yml文件中可以对网站信息进行修改,将theme: landscape修改成theme: smackdown(自己主题文件名),注意冒号后面有空格 3).smackdown里的_config.yml文件是主题的配置文件，可以对主题进行修改 4).将blog部署到github # hexo clean # hexo g # hexo d 15.发布文章# hexo n &quot;文章名字&quot; 在blog根目录下的source文件夹中的_post文件夹中多了一个文章名字.md文件 然后将写好的md文件内容复制到刚生成的md文件中,回到博客目录，部署博客 # hexo clean # hexo d -g 现在就可以开始个人博客之旅了 至此博客基本就搭建完毕]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
